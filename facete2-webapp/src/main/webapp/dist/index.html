<!DOCTYPE html>
<html ng-app="Facete2">

<head>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

    <title>Facete II</title>
	
    <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->
    <link rel="stylesheet" href="styles/e065d650.main.css"/>

	
    <script src="scripts/0bb5dd39.scripts.js"></script>

<!--    <script src="js/jassa-ui-angular-geo-openlayers-tpls.js"></script> -->
	
	<script type="text/javascript">
    _.mixin(_.str.exports());

	var rdf = Jassa.rdf;
	var sparql = Jassa.sparql;
    var service = Jassa.service;
	var sponate = Jassa.sponate;
    var facete = Jassa.facete;
	var geo = Jassa.geo;
	var util = Jassa.util;
	
	var client = Jassa.client;

    var myModule = angular.module('Facete2', ['ui.bootstrap', 'ui.jassa', 'ngGrid', 'ui.jassa.openlayers', 'ngSanitize']);

    

    /*
    var test = new service.SparqlServiceHttp('http://localhost:7532/api/path-finding?service-uri=http%3A%2F%2Fcstadler.aksw.org%2Fconti%2Ffreebase%2Fgermany%2Fsparql&default-graph-uri=http%3A%2F%2Ffreebase.com%2F2013-09-22%2Fdata%2F&source-element=%3Fs+%3F_p_+%3F_o_&source-var=s&target-element=%3Fs+<http%3A%2F%2Fwww.w3.org%2F2003%2F01%2Fgeo%2Fwgs84_pos%23long>+%3Fx+%3B++<http%3A%2F%2Fwww.w3.org%2F2003%2F01%2Fgeo%2Fwgs84_pos%23lat>+%3Fy&target-var=s&js-service-uri=');
    var qe = test.createQueryExecution('Select * { ?s ?p ?o } Limit 10');
    var promise = qe.execSelect();
    promise.done(function(rs) {
       while(rs.hasNext()) {
           var binding = rs.next();
           console.log('Binding ' + binding);
       } 
    }).fail(function() {
        alert(JSON.stringify(arguments));
    });
    */

    (function() {
	    var ns = service;
	    
	    ns.QueryExecutionDummy = Class.create(ns.QueryExecution, {
	        createPromise: function(val) {
	            var deferred = jQuery.Deferred();
	            deferred.resolve(val);
	            return deferred.promise();            
	        },
	        
	        execAsk: function() {
	            var result = this.createPromise(false);
	            return result;
	        },
	        
	        execSelect: function() {
	            var rs = new ns.ResultSetArrayIteratorBinding(new util.IteratorArray([]));
	            var result = this.createPromise(rs);
	            return result;
	        },
	        
	        setTimeout: function(timeoutInMillis) {
	            
	        }
	    });
	        
	    ns.SparqlServiceDummy = Class.create(ns.SparqlService, {
	        
	        createQueryExecution: function(query) {
	            return new ns.QueryExecutionDummy();
	        },
	        
	        getStateId: function() {
	            return 'dummyId';
	        },
	        
	        getStateHash: function() {
	            return 'dummyHash';
	        },
	        
	        hashCode: function() {
	            return 'dummy-sparql-service';
	        }
	    });
    })();
    
    (function() {
	    var ns = facete;
	    ns.QueryFactoryConst = Class.create(ns.QueryFactory, {
	        initialize: function(query) {
	            this.query = query;
	        },
	        
	        createQuery: function() {
	            return this.query;
	        }
	    });
    })();
    
    
    myModule.controller('MyCtrl', ['$scope', '$q', '$rootScope', function($scope, $q, $rootScope) {

		$scope.active = {};

		var vs = rdf.NodeFactory.createVar('s');

        
		/* Dummy init */
        var dummyQuery = new sparql.Query();
        dummyQuery.getProjectVars().add(vs);
        dummyQuery.getElements().push(new sparql.ElementTriplesBlock([new rdf.Triple(vs, vs, vs)]));
        
        var tmpTableMod = new facete.TableMod();
        tmpTableMod.addColumn('s');
        $scope.active.facetTableConfig = {
            queryFactory: new facete.QueryFactoryConst(dummyQuery),
            tableMod: tmpTableMod
        };

		
		
		var facetTreeConfig = new facete.FacetTreeConfig();

		var facetConfig = facetTreeConfig.getFacetConfig();
		var pathTaggerManager = facetConfig.getPathTaggerManager()
		var taggerMap = pathTaggerManager.getTaggerMap();
		
		
        var facetTableConfig = new facete.FacetTableConfig(facetConfig);
		var tableMod = facetTableConfig.getTableMod();
		tableMod.addColumn('s');
		
		taggerMap.table = new facete.ItemTaggerMembership(facetTableConfig.getPaths());

		
		
		var geoConceptFactory = new facete.ConceptFactoryFacetTreeConfig(facetTreeConfig);


		var conceptFalse = new facete.Concept(sparql.ElementString.create('?s a <http://foo.bar>'), vs);

		var filterConceptFactory = new facete.ConceptFactoryConst(conceptFalse)
		

		
		$scope.facetTreePluginContext = {
			toggleTableLink: function(path) {
			    if($scope.facetTableConfig) {
                	$scope.facetTableConfig.togglePath(path);
			    }
			}
		};


		$scope.facetTreePlugins = ['<a ng-show="data.isHovered || data.item.getTags().table.isContained" href="" ng-click="context.toggleTableLink(data.item.getPath())"><span class="glyphicon glyphicon-list-alt"></span></a>'];

		
		
//         var tableMod = new facete.TableMod();
//         //tableMod.addColumn('s');
//         tableMod.addColumn('_p_');
//         tableMod.addColumn('_o_');

		
		$scope.active.sparqlService = new service.SparqlServiceDummy();
		$scope.active.geoConceptFactory = geoConceptFactory;

        $scope.active.serviceConfigs = [{
            name: 'Freebase Germany',
            dataService: {
                serviceIri: 'http://cstadler.aksw.org/conti/freebase/germany/sparql',
                defaultGraphIris: ['http://freebase.com/2013-09-22/data/']
            },
            joinSummaryService: {
                serviceIri: null,
                defaultGraphIris: []
            },
            conceptPathFinderApiUrl: 'api/path-finding',
            facetTreeConfig: facetTreeConfig,
            mapConfig: {
                mapFactory: geo.GeoMapFactoryUtils.wgs84MapFactory,
                geoConcept: geo.GeoConcepts.conceptWgs84,
			    quadTreeConfig: {
					maxItemsPerTileCount: 1000,
					maxGlobalItemCount: 2000
				}
            }
        }, {        
            name: 'FP7 ICT Project Partners (remote)',
            dataService: {
                serviceIri: 'http://fp7-pp.publicdata.eu/sparql',
                defaultGraphIris: ['http://fp7-pp.publicdata.eu/']
            },
            joinSummaryService: {
                serviceIri: null,
                defaultGraphIris: []
            },
            conceptPathFinderApiUrl: 'api/path-finding',        
            facetTreeConfig: facetTreeConfig,
            mapConfig: {
                mapFactory: geo.GeoMapFactoryUtils.wgs84MapFactory,
                geoConcept: geo.GeoConcepts.conceptWgs84,
			    quadTreeConfig: {
					maxItemsPerTileCount: 1000,
					maxGlobalItemCount: 2000
				}
            }
        }, {        
            name: 'FP7 ICT Project Partners (local)',
            dataService: {
                serviceIri: 'http://localhost:8801/sparql',
                defaultGraphIris: ['http://fp7-pp.publicdata.eu/']
            },
            joinSummaryService: {
                serviceIri: null,
                defaultGraphIris: []
            },
            conceptPathFinderApiUrl: 'api/path-finding',        
            facetTreeConfig: facetTreeConfig,
            mapConfig: {
                mapFactory: geo.GeoMapFactoryUtils.wgs84MapFactory,
                geoConcept: geo.GeoConcepts.conceptWgs84,
			    quadTreeConfig: {
					maxItemsPerTileCount: 1000,
					maxGlobalItemCount: 2000
				}
            }
        }, {
            name: 'GeoKnow Demo Dataset (remote)',
            dataService: {
                serviceIri: 'http://cstadler.aksw.org/geoknow/sparql',
                defaultGraphIris: []
            },
            joinSummaryService: {
                serviceIri: null,
                defaultGraphIris: []
            },
            conceptPathFinderApiUrl: 'api/path-finding',
            facetTreeConfig: facetTreeConfig,
            mapConfig: {
                mapFactory: geo.GeoMapFactoryUtils.wgs84MapFactory,
                geoConcept: geo.GeoConcepts.conceptWgs84,
			    quadTreeConfig: {
					maxItemsPerTileCount: 1000,
					maxGlobalItemCount: 2000
				}
            }
        }, {
            name: 'GeoKnow Demo Dataset (local)',
            dataService: {
                serviceIri: 'http://localhost:8870/sparql',
                defaultGraphIris: []
            },
            joinSummaryService: {
                serviceIri: null,
                defaultGraphIris: []
            },
            conceptPathFinderApiUrl: 'api/path-finding',
            facetTreeConfig: facetTreeConfig,
            mapConfig: {
                mapFactory: geo.GeoMapFactoryUtils.wgs84MapFactory,
                geoConcept: geo.GeoConcepts.conceptWgs84,
			    quadTreeConfig: {
					maxItemsPerTileCount: 1000,
					maxGlobalItemCount: 2000
				}
            }
        }, {        
            name: 'DBpedia',
            dataService: {
                serviceIri: 'http://dbpedia.org/sparql',
                defaultGraphIris: ['http://dbpedia.org']
            },
            joinSummaryService: {
                serviceIri: 'http://cstadler.aksw.org/service/join-summary/sparql',
                defaultGraphIris: ['http://dbpedia.org/2013-12-22/join-summary-essential/']
            },
            conceptPathFinderApiUrl: 'api/path-finding',        
            facetTreeConfig: facetTreeConfig,
            mapConfig: {
                mapFactory: geo.GeoMapFactoryUtils.wgs84MapFactory,
                geoConcept: geo.GeoConcepts.conceptWgs84,
			    quadTreeConfig: {
					maxItemsPerTileCount: 1000,
					maxGlobalItemCount: 2000
				}
            }
        }, {
            name: 'LinkedGeoData',
            dataService: {
                serviceIri: 'http://linkedgeodata.org/sparql',
                defaultGraphIris: ['http://linkedgeodata.org']
            },
            joinSummaryService: {
                serviceIri: 'http://linkedgeodata.org/join-summary/sparql',
                defaultGraphIris: ['http://linkedgeodata.org/join-summary']
            },
            conceptPathFinderApiUrl: 'api/path-finding',
            facetTreeConfig: facetTreeConfig,
            mapConfig: {
                mapFactory: geo.GeoMapFactoryUtils.wgs84MapFactory,
                geoConcept: geo.GeoConcepts.conceptWgs84,
			    quadTreeConfig: {
					maxItemsPerTileCount: 1000,
					maxGlobalItemCount: 2000
				}
            }
        }, {
            name: 'GeoStats (remote)',
            dataService: {
                serviceIri: 'http://cstadler.aksw.org/service/geostats/sparql',
                defaultGraphIris: ['http://geostats.aksw.org/']
            },
            joinSummaryService: {
                serviceIri: null,
                defaultGraphIris: []
            },
            conceptPathFinderApiUrl: 'api/path-finding',
            facetTreeConfig: facetTreeConfig,
            mapConfig: {
                mapFactory: geo.GeoMapFactoryUtils.ogcVirtMapFactory,
                geoConcept: geo.GeoConcepts.conceptGeoVocab,
			    quadTreeConfig: {
					maxItemsPerTileCount: 1000,
					maxGlobalItemCount: 2000
				}
            }
        }, {
            name: 'GeoStats (local)',
            dataService: {
                serviceIri: 'http://localhost:8860/sparql',
                defaultGraphIris: ['http://localhost/geostats.nt']
            },
            joinSummaryService: {
                serviceIri: null,
                defaultGraphIris: []
            },
            conceptPathFinderApiUrl: 'api/path-finding',
            facetTreeConfig: facetTreeConfig,
            mapConfig: {
                mapFactory: geo.GeoMapFactoryUtils.ogcVirtMapFactory,
                geoConcept: geo.GeoConcepts.conceptGeoVocab,
			    quadTreeConfig: {
					maxItemsPerTileCount: 1000,
					maxGlobalItemCount: 2000
				}
            }
        }, {
            name: 'LGD Sparqlify Localhost',
            dataService: {
                serviceIri: 'http://localhost:7531/sparql',
                defaultGraphIris: []
            },
            joinSummaryService: {
                serviceIri: 'http://linkedgeodata.org/join-summary/sparql',
                defaultGraphIris: ['http://linkedgeodata.org/join-summary']
            },
            conceptPathFinderApiUrl: 'api/path-finding',
            facetTreeConfig: facetTreeConfig,
            mapConfig: {
                mapFactory: geo.GeoMapFactoryUtils.wgs84MapFactory,
                geoConcept: geo.GeoConcepts.conceptWgs84,
			    quadTreeConfig: {
					maxItemsPerTileCount: 1000,
					maxGlobalItemCount: 2000
				}
            }
        }];

        
        /**
         * Init of derived attributes
         *
         */
        _($scope.active.serviceConfigs).each(function(serviceConfig) {
            // Create the facetTableConfig
// 			var facetTreeConfig = serviceConfig.facetTreeConfig;
//             var facetConfig = facetTreeConfig.getFacetConfig()


            serviceConfig.facetTableConfig = facetTableConfig;

            // Init the taggerMap
//     		var pathTaggerManager = facetConfig.getPathTaggerManager()
//     		var taggerMap = pathTaggerManager.getTaggerMap();
    		
//     		taggerMap.table = new facete.ItemTaggerMembership(facetTableConfig.getPaths());
    		
    		// Init the tableMod
//     		var tableMod = facetTableConfig.getTableMod();
//     		tableMod.addColumn('s');
        });

        
        $scope.active.path = null;

		
		/*
		 * Concept Path Finding
		 */
		var refresh = function(config) {
			
		    var conceptPathFinderApiUrl = config.conceptPathFinderApiUrl;
		    var sparqlServiceIri = config.dataService.serviceIri;
		    var defaultGraphIris = config.dataService.defaultGraphIris;
		    var joinSummaryServiceIri = config.joinSummaryService.serviceIri;
		    var joinSummaryDefaultGraphIris = config.joinSummaryService.defaultGraphIris;
		    
		    
		    var geoConcept = config.mapConfig.geoConcept;
		    
		    var conceptPathFinder = new client.ConceptPathFinderApi(conceptPathFinderApiUrl, sparqlServiceIri, defaultGraphIris, joinSummaryServiceIri, joinSummaryDefaultGraphIris);

            var facetTreeConfig = config.facetTreeConfig;
    		var conceptFactory = new facete.ConceptFactoryFacetTreeConfig(facetTreeConfig);

		    
		    var sourceConcept = conceptFactory.createConcept(); 	
			var targetConcept = geoConcept;
								
			
// 			var cpfSparqlService = conceptPathFinder.createSparqlService(sourceConcept, targetConcept);
// 			var qe = cpfSparqlService.createQueryExecution('Select * { ?s ?p ?o } Limit 10');
// 			qe.execSelect().done(function(rs) {
// 				alert(JSON.stringify(rs.getBindings()));
// 			}).fail(function() {
// 			    alert('fail');
// 			});
			
			
		    var promise = conceptPathFinder.findPaths(sourceConcept, targetConcept);
			var result = sponate.angular.bridgePromise(promise, $q.defer(), $rootScope);
	
			result.then(function(paths) {
			    var tmp = _(paths).map(function(path) {

			        var pathName = path.toString();
			        if(pathName === '') {
			            pathName = '(empty path)';
			        }

			        var r = {
						name: pathName,
						path: path
					};
			        return r;
			    });
			   
			    $scope.active.geoPaths = tmp;
			}, function(err) {
			    alert(err.responseText);
			});
		};
		        
       	var refreshServices = function(config) {
       	    if(!config) {
				return;
       	    }

            var dataCnf = config.dataService;

            var facetTreeConfig = config.facetTreeConfig;
            
    		var sparqlService = new service.SparqlServiceHttp('cache/sparql', dataCnf.defaultGraphIris, {}, {'service-uri': dataCnf.serviceIri});

    		sparqlService = new service.SparqlServiceCache(sparqlService);
    		sparqlService = new service.SparqlServicePaginate(sparqlService, 1000);

//     		debugger;    		
//     		var query = new sparql.Query();
//     		query.getElements().push(new sparql.ElementTriplesBlock([new rdf.Triple(rdf.NodeFactory.createVar('s'), rdf.NodeFactory.createVar('p'), rdf.NodeFactory.createVar('o'))]));
//     		query.setResultStar(true);
//     		query.setLimit(10);    		
//     		sparqlService.createQueryExecution(query).execSelect().done(function(rs) {
//     		    var hash = Jassa.util.ObjectUtils.hashCode(sparqlService);
//     			alert(hash);
//     		});

    		
    		var conceptFactory = new facete.ConceptFactoryFacetTreeConfig(facetTreeConfig);


    		//var mapFactory =  geo.GeoMapFactoryUtils.ogcVirtMapFactory;
    		var mapFactory = config.mapFactory;
    		    		
    		$scope.active.sparqlService = sparqlService;		
            $scope.active.facetTreeConfig = facetTreeConfig;
            
            //$scope.path = null;

            /*
            var facetConfig = facetTreeConfig.getFacetConfig();
    		var facetConceptFactory = new facete.ConceptFactoryFacetConfig(facetConfig);

            var dataConcept = facete.ConceptUtils.createSubjectConcept(vs);
            var elementFactory = new sparql.ElementFactoryJoinConcept(new facete.ConceptFactoryConst(dataConcept), filterConceptFactory);
                
            var queryFactory = new facete.QueryFactoryTableMod(elementFactory, tableMod);

    		$scope.active.facetTableConfig = {
    			queryFactory: queryFactory,
    			tableMod: tableMod
    		};
            */

            
    		/*
    		 * <- Facet Tree 'Link-Facet-To-Table' Plugin
    		 */
    		var facetConfig = facetTreeConfig.getFacetConfig()
            var facetTableConfig = config.facetTableConfig;
    		var tableMod = facetTableConfig.getTableMod();

    		
            var dataConcept = facetTableConfig.createDataConcept();
            var elementFactory = new sparql.ElementFactoryJoinConcept(new facete.ConceptFactoryConst(dataConcept), filterConceptFactory);           
            var queryFactory = new facete.QueryFactoryTableMod(elementFactory, tableMod);

    		$scope.active.facetTableConfig = {
    			queryFactory: queryFactory,
    			tableMod: tableMod
    		};
    		
    		// HACK!
    		$scope.facetTableConfig = facetTableConfig;
    		/*
    		 * ->
    		 */
            

            
            
            
    		var mapConfig = config.mapConfig;
    		
            $scope.active.dataSources = [{
    			sparqlService: sparqlService,
    			mapFactory: mapConfig.mapFactory,
    			conceptFactory: geoConceptFactory,
    		    quadTreeConfig: mapConfig.quadTreeConfig
    		}];

        };

        $scope.active.dataSources = [];
        
        
        $scope.setDataSource = function(item) {
            alert(JSON.stringify(item));
        };
        
//         $scope.$watch('dataSourceSelection.active', function(val) {
// 			alert(JSON.stringify(val));
//         });

		$scope.ObjectUtils = util.ObjectUtils;
		
		
		//$scope.$watch('ObjectUtils.hashCode(facetTreeConfig)', function() {
		$scope.$watch('ObjectUtils.hashCode(active.service)', function() {

		    var config = $scope.active.service;
		    if(config) {
		    	refreshServices(config);
		    	refresh(config);
		    }
		});
		
        $scope.active.service = $scope.active.serviceConfigs[0];


		
		$scope.setGeoPath = function(path) {
		    $scope.active.geoConceptFactory.setPath(path);
		};

        $scope.selectFacet = function(path) {
            $scope.active.path = path;
        };

        $scope.selectGeom = function(data) {
            //alert('Select: ' + JSON.stringify(data));
			var node = data.id;
            var ev = new sparql.ExprVar(vs);
            var nodeValue = sparql.NodeValue.makeNode(node);
            var expr = new sparql.E_Equals(ev, nodeValue);
            var element = new sparql.ElementFilter(expr);
			var concept = new facete.Concept(element, vs);

			filterConceptFactory.setConcept(concept);

			if(!$scope.$$phase) {
                $scope.$apply();
            }
        }

        $scope.unselectGeom = function(data) {
            //alert('Unselect: ' + JSON.stringify(data));
			filterConceptFactory.setConcept(conceptFalse);
			if(!$scope.$$phase) {
                $scope.$apply();
            }
        }


        
        $scope.nextConceptSpaceId = 1;
        $scope.conceptSpaces = [];
        
        
        $scope.addConceptSpace = function() {
            var conceptSpaceId = '' + ($scope.nextConceptSpaceId++);
            
			var config = {
			    id: conceptSpaceId,
			    name: 'concept-' + conceptSpaceId
			};
			
			$scope.conceptSpaces.push(config);
        };
        
        $scope.selectConceptSpace = function(index) {
			_($scope.conceptSpaces).each(function(conceptSpace) {
				conceptSpace.active = false;
			});
			
			$scope.conceptSpaces[index].active = true;
        };
        
        $scope.removeConceptSpace = function(index) {
			$scope.conceptSpaces.splice(index, 1);
        };


    }]);
	</script>

</head>

<body ng-controller="MyCtrl">

	<nav class="navbar navbar-default" role="navigation">
		<div class="container-fluid">
			<!-- Brand and toggle get grouped for better mobile display -->
   			<div class="navbar-header">
				<button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
					<span class="sr-only">Toggle navigation</span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
				</button>
				<a class="navbar-brand" href="#">Facete II</a>
			</div>
			
<!-- 			<div class="collapse navbar-collapse"> -->
<!--       			<ul class="nav navbar-nav"> -->
<!--         			<li class="active"><a href="#">Source Code</a></li> -->
<!--         			<li><a href="#">Link</a></li> -->
<!--         		</ul> -->
<!--         	</div> -->
		</div>
	</nav>

	<div style="position: absolute; top: 50px; left: 0px; width: 500px; bottom: 0px; overflow: auto; padding: 5px; pointer-events:none">
<!-- 		<div style="width:100%;"> -->
<!-- 			<div style="min-height: 50px;"/></div> -->
<!-- 		</div> -->


		<accordion close-others="false">
<!-- 			<accordion-group heading="Search" style="pointer-events: auto;"> -->
<!-- 				<input type="text" ng-model="active.searchString"></input>				 -->
<!-- 			</accordion-group> -->
		
			<accordion-group heading="Data Sources" style="pointer-events: auto">
				<select ng-model="active.service" ng-options="item.name for item in active.serviceConfigs"></select>
			</accordion-group>

			<accordion-group heading="Concepts" style="pointer-events: auto">
				<ul>
			    	<li ng-show="conceptSpaces.length == 0" class="inactive">(there are no concepts yet)</li>
				    <li ng-repeat="conceptSpace in conceptSpaces" ng-class="{'highlite': conceptSpace.active}">
				    	<a href="" ng-click="removeConceptSpace($index)"><span class="glyphicon glyphicon-remove-circle"></span></a>
				    	<a href="" ng-click="selectConceptSpace($index)">{{conceptSpace.name}}</a>
				   	</li>
				</ul>
				
				<button class="btn btn-primary" ng-click="addConceptSpace()">Create a new Concept</button>
			</accordion-group>

			<accordion-group heading="GeoPaths" class="portlet" style="pointer-events: auto">
				<tabset>
					<tab heading="Candidates">
		   				<ul>
		   					<li ng-repeat="geoPath in active.geoPaths">
		   						<a href="" ng-click="setGeoPath(geoPath.path)">{{geoPath.name}}</a>
		   					</li>
		   				</ul>
				  	</tab>
					<tab heading="Active">
						To be done
					</tab>
				</tabset>
			</accordion-group>

			<accordion-group heading="Facets" style="pointer-events: auto">
				<div class="panel panel-info"> 
					<div class="panel-heading portlet-heading">
						Facet Tree
					</div>
					<div class="panel-body">
					   <facet-tree sparql-service="active.sparqlService" facet-tree-config="active.facetTreeConfig" select="selectFacet(path)" plugins="facetTreePlugins" plugin-context="facetTreePluginContext"></facet-tree>
					</div>
				</div>
		
				<div class="panel panel-info"> 
					<div class="panel-heading portlet-heading">
						Facet Values
					</div>
					<div class="panel-body">
		   				<facet-value-list sparql-service="active.sparqlService" facet-tree-config="active.facetTreeConfig" path="active.path"></facet-value-list>
					</div>
				</div>
		
				<div class="panel panel-info"> 
					<div class="panel-heading portlet-heading">
						Constraints
					</div>
					<div class="panel-body">
		   				<constraint-list sparql-service="active.sparqlService" facet-tree-config="active.facetTreeConfig"></constraint-list>
					</div>
				</div>
			</accordion-group>
		</accordion>

	</div>

	<accordion style="position: absolute; bottom: 30px; left: 520px">
		<accordion-group heading="Data">
			<sparql-table sparql-service="active.sparqlService" config="active.facetTableConfig"></sparql-table>
		</accordion-group>
	</accordion>

<!-- 	<div class="panel panel-info" style="position: absolute; bottom: 30px; left: 520px;">  -->
<!-- 		<div class="panel-heading"> -->
<!-- 			<i class="panel-title">Data</i> -->
<!-- 		</div> -->
<!-- 		<div class="panel-body" style="max-height: 500px; overflow: auto"> -->
<!-- 			<sparql-table sparql-service="active.sparqlService" config="active.facetTableConfig"></sparql-table> -->
<!-- 		</div> -->
<!-- 	</div> -->

	<div class="panel panel-info" style="display: none; position: absolute; bottom: 30px; left: 520px; height: 500px"> 
		<div class="panel-heading">
			<i class="panel-title">Register Data Source</i>
		</div>
		<div class="panel-body">
			<div>
				<label>Title: <input type="text"><select></select></label>
			</div>

			<div>
				<label>Sparql Service Iri: <input type="text"></label>
				<label>Named Graphs: <select></select></label>
			</div>
			
			<div>
				<label>Join Summary Service: <input type="text"></label>
				<label>Join Summary Graphs: <input type="text"></label>
			</div>
		</div>
	</div>


    <div jassa-map-ol="map" style="position: absolute; left: 0px; top: 0px; width: 100%; height: 100%; z-index:-9999" config="active.dataSources" select="selectGeom(data)" unselect="unselectGeom(data)"></div>

	<a href="https://github.com/GeoKnow/Facete2" target="_blank"><img style="position: absolute; top: 0; right: 0; border: 0" src="images/39c9135d.forkme_right_green_007200.png" alt="Fork me on GitHub"></a>

</body>

</html>