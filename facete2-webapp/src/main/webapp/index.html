<!DOCTYPE html>
<html ng-app="Facete2">

<head>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

    <title>Facete II</title>
	
    <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->
    <!-- build:css(.tmp) styles/main.css -->

    <!-- bower:css -->
    <link rel="stylesheet" href="bower_components/bootstrap/dist/css/bootstrap.css" />
    <link rel="stylesheet" href="bower_components/jassa-ui-angular/jassa-ui-angular.css" />
    <link rel="stylesheet" href="bower_components/jassa-ui-angular-openlayers/jassa-ui-angular-openlayers.css" />
    <!-- endbower -->

	<link rel="stylesheet" href="bower_components/ng-grid-bower/ng-grid.css" />
    <link rel="stylesheet" href="bower_components/jquery-ui/themes/base/jquery.ui.resizable.css" />

    <link rel="stylesheet" href="styles/facete-style.css" />

    <!-- endbuild -->

	
    <!-- build:js scripts/scripts.js -->

    <script src="bower_components/jscache/cache.js"></script>

    <!-- bower:js -->
    <script src="bower_components/jquery/jquery.js"></script>
    <script src="bower_components/jquery-ui/ui/jquery-ui.js"></script>
    <script src="bower_components/underscore/underscore.js"></script>
    <script src="bower_components/jassa/jassa.js"></script>
    <script src="bower_components/angular/angular.js"></script>
    <script src="bower_components/bootstrap/dist/js/bootstrap.js"></script>
    <script src="bower_components/ng-grid-bower/ng-grid.js"></script>
    <script src="bower_components/angular-sanitize/angular-sanitize.js"></script>
    <script src="bower_components/jassa-ui-angular/jassa-ui-angular-tpls.js"></script>
    <script src="bower_components/jassa-ui-angular-openlayers/jassa-ui-angular-openlayers-tpls.js"></script>
    <!-- endbower -->



	<script src="scripts/lib/ng-grid-flexible-height/ng-grid-flexible-height.js"></script>

    <script src="scripts/lib/angular-ui/0.10.0/ui-bootstrap-tpls-0.10.0.js"></script>
    <script src="bower_components/underscore.string/lib/underscore.string.js"></script>
    <script src="bower_components/openlayers/lib/OpenLayers.js"></script>

    <!-- endbuild -->

<!--    <script src="js/jassa-ui-angular-geo-openlayers-tpls.js"></script> -->
	
	<script type="text/javascript">
    _.mixin(_.str.exports());

	var rdf = Jassa.rdf;
	var sparql = Jassa.sparql;
    var service = Jassa.service;
	var sponate = Jassa.sponate;
    var facete = Jassa.facete;
	var geo = Jassa.geo;
	var util = Jassa.util;
	
	var client = Jassa.client;

    var myModule = angular.module('Facete2', ['ui.bootstrap', 'ui.jassa', 'ngGrid', 'ui.jassa.openlayers', 'ngSanitize']);

    
    myModule.filter('reverse', function() {
		return function(items) {
			return items.slice().reverse();
		};
	});
    

    /*
    var test = new service.SparqlServiceHttp('http://localhost:7532/api/path-finding?service-uri=http%3A%2F%2Fcstadler.aksw.org%2Fconti%2Ffreebase%2Fgermany%2Fsparql&default-graph-uri=http%3A%2F%2Ffreebase.com%2F2013-09-22%2Fdata%2F&source-element=%3Fs+%3F_p_+%3F_o_&source-var=s&target-element=%3Fs+<http%3A%2F%2Fwww.w3.org%2F2003%2F01%2Fgeo%2Fwgs84_pos%23long>+%3Fx+%3B++<http%3A%2F%2Fwww.w3.org%2F2003%2F01%2Fgeo%2Fwgs84_pos%23lat>+%3Fy&target-var=s&js-service-uri=');
    var qe = test.createQueryExecution('Select * { ?s ?p ?o } Limit 10');
    var promise = qe.execSelect();
    promise.done(function(rs) {
       while(rs.hasNext()) {
           var binding = rs.next();
           console.log('Binding ' + binding);
       } 
    }).fail(function() {
        alert(JSON.stringify(arguments));
    });
    */

    (function() {
	    var ns = service;
	    
	    ns.QueryExecutionDummy = Class.create(ns.QueryExecution, {
	        createPromise: function(val) {
	            var deferred = jQuery.Deferred();
	            deferred.resolve(val);
	            return deferred.promise();            
	        },
	        
	        execAsk: function() {
	            var result = this.createPromise(false);
	            return result;
	        },
	        
	        execSelect: function() {
	            var rs = new ns.ResultSetArrayIteratorBinding(new util.IteratorArray([]));
	            var result = this.createPromise(rs);
	            return result;
	        },
	        
	        setTimeout: function(timeoutInMillis) {
	            
	        }
	    });
	        
	    ns.SparqlServiceDummy = Class.create(ns.SparqlService, {
	        
	        createQueryExecution: function(query) {
	            return new ns.QueryExecutionDummy();
	        },
	        
	        getStateId: function() {
	            return 'dummyId';
	        },
	        
	        getStateHash: function() {
	            return 'dummyHash';
	        },
	        
	        hashCode: function() {
	            return 'dummy-sparql-service';
	        }
	    });
    })();
    
    (function() {
	    var ns = facete;
	    ns.QueryFactoryConst = Class.create(ns.QueryFactory, {
	        initialize: function(query) {
	            this.query = query;
	        },
	        
	        createQuery: function() {
	            return this.query;
	        }
	    });
    })();
    
    
    myModule.controller('MyCtrl', ['$scope', '$q', '$rootScope', function($scope, $q, $rootScope) {

        /**
         * Used for progress bar
         */
        $scope.Math = Math;


		$scope.active = {};

		

		/* Application UI state */
        $scope.app = {
   			search: {
   				show: false,
   				isOpen: false
   			},
   			dataSources: {
   				isOpen: false,
   				showAddDialog: false
   			},
   			data: {
   				isOpen: false,
   				originalBounds: {}, // Bounds to restore size
   				bounds: {} // Bounds for current size; watched and synced by the directive
   			},
   			geoLinks: {
   				isOpen: false
   			},
   			facets: {
   			    isOpen: false
   			}
        };

		
        var resizableConfigEnabled = {
		    handles: 'n, e, ne',
		    containment: 'parent',
		    
		    create: function(event, ui) {
		        jQuery(event.target).on('resize', function (e, ui) {
		            // Prevent the top attribute from getting set
		            jQuery(event.target).css('top', '');
		        });
		    },
		    
		    // Resize might not working properly, if there are parent elements with pointer-events: none involved
		    start: function(event, ui) {
		        var el = jQuery(event.target);
		                        
		        this.pointerEventsResets = el.parents().filter(function() {
		            var attrVal = jQuery(this).css('pointer-events');
		            var r = attrVal === 'none';
		            //console.log('resize', this, attrVal, r)
		            return r;
		        });
		        
		        this.pointerEventsResets.css('pointer-events', 'auto');
		    },
		    stop: function(event, ui) {
		        this.pointerEventsResets.css('pointer-events', 'none');
		    }
		};

        var resizableConfigDisabled = {handles: 'none', disabled: true};

        $scope.resizableConfig = resizableConfigDisabled;

        
        $scope.$watch('app.data.isOpen', function(state) {
            $scope.resizableConfig = state ? resizableConfigEnabled : resizableConfigDisabled;
        });
            
        

		
		
        $scope.edit = {
	        id: null,
	        dataServiceIri: '',
	        dataGraphIris: '',
	        jsServiceIri: '',
	        jsGraphIris: ''
		};
            
        
        var storeApiUrl = 'api/store';

        
        
        var facetTableConfig; // Initialized later - TODO Fix the order
        
        var createDefaultWorkspaceConfig = function() {
	        var result = {
		        name: 'Unnamed Data Source',
		        dataService: {
		            serviceIri: '',
		            defaultGraphIris: []
		        },
		        joinSummaryService: {
		            serviceIri: '',
		            defaultGraphIris: []
		        },
		        conceptPathFinderApiUrl: 'api/path-finding',        
		        facetTreeConfig: facetTreeConfig,
		        mapConfig: {
		            mapFactory: geo.GeoMapFactoryUtils.wgs84MapFactory,
		            geoConcept: geo.GeoConcepts.conceptWgs84,
					quadTreeConfig: {
						maxItemsPerTileCount: 1000,
						maxGlobalItemCount: 2000
		        	}
		      	},
	            facetTableConfig: facetTableConfig
		    };
	        
	        return result;
        };
        
        
        var applyScope = function() {
			if(!$scope.$$phase) {
                $scope.$apply();
            }			
        };
        
        refreshDataSources = function() {
			var spec = {
				url: storeApiUrl + '/loadState',
				traditional: true,
				data: {
					type: 'dataSource'
				},
				dataType: 'json'
			};
            
            jQuery.ajax(spec).done(function(response) {
                
                var configs = _(response).map(function(record) {
                    var item = record.data;
                    item.id = record.id;
                    
                    var spec = createDefaultWorkspaceConfig();
                    console.log('ITEM', item);
                    spec.id = item.id;
                    spec.name = item.name;
                    spec.dataService.serviceIri = item.dataServiceIri;
                    spec.dataService.defaultGraphIris = item.dataGraphIris;
                    spec.joinSummaryService.serviceIri = item.jsServiceIri;
                    spec.joinSummaryService. defaultGraphIris = item.jsGraphIris;
                    
                    return spec;
                });
                console.log('CONFIGS', configs);
                
                $scope.active.serviceConfigs = configs;
                
                applyScope();
                //alert('yay' + JSON.stringify(response));
            }).fail(function() {
                alert('Failed to retrieve data sources');
            });
        };
        
        
        $scope.deleteDataSource = function(id) {
            
            var c = confirm('Delete dataset with id ' + id + '?');
            if(!c) {
                return;
            }

			var spec = {
					url: storeApiUrl + '/deleteState',
					type: 'POST',
					traditional: true,
					data: {
					    type: 'dataSource',
					    id: id
					},
					dataType: 'json'
			};

            jQuery.ajax(spec).done(function(response) {
				// FIXME Verify the response for success
            }).fail(function() {
				alert('Failed to delete data source with id ' + id);
		        //$scope.active.service = serviceConfigs.length === 0 ? null : serviceConfigs[0];

            }).then(function() {
            	refreshDataSources();                
            });

        }
        
        $scope.addDataSource = function() {
            var raw = _($scope.edit).clone();
            
            
            raw.dataGraphIris = raw.dataGraphIris.match(/\S+/g);
            raw.jsGraphIris = raw.jsGraphIris.match(/\S+/g);
            
            var data = JSON.stringify(raw);
            
			var spec = {
				url: storeApiUrl + '/saveState',
				type: 'POST',
				traditional: true,
				data: {
				    type: 'dataSource',
				    data: data
				},
				dataType: 'json'
			};
            
            jQuery.ajax(spec).done(function(response) {
                // Hide data source creation dialog
                //$scope.app.dataSources.isOpen = false;
                $scope.app.dataSources.showAddDialog=false

            	refreshDataSources();
    			//alert('yay' + JSON.stringify(response));
            }).fail(function() {
				alert('Failed to store data');
            });
            
        };

		
		
		var vs = rdf.NodeFactory.createVar('s');

        
		/* Dummy init */
        var dummyQuery = new sparql.Query();
        dummyQuery.getProject().add(vs);
        dummyQuery.getElements().push(new sparql.ElementTriplesBlock([new rdf.Triple(vs, vs, vs)]));
        
        var tmpTableMod = new facete.TableMod();
        tmpTableMod.addColumn('s');
        $scope.active.facetTableConfig = {
            queryFactory: new facete.QueryFactoryConst(dummyQuery),
            tableMod: tmpTableMod
        };


		var facetTreeConfig = new facete.FacetTreeConfig();

		var facetConfig = facetTreeConfig.getFacetConfig();
		var pathTaggerManager = facetConfig.getPathTaggerManager()
		var taggerMap = pathTaggerManager.getTaggerMap();
		
		
        facetTableConfig = new facete.FacetTableConfig(facetConfig);
		var tableMod = facetTableConfig.getTableMod();
		tableMod.addColumn('s');
		
		taggerMap.table = new facete.ItemTaggerMembership(facetTableConfig.getPaths());

		
		
		var geoConceptFactory = new facete.ConceptFactoryFacetTreeConfig(facetTreeConfig);


		var conceptFalse = new facete.Concept(sparql.ElementString.create('?s a <http://foo.bar>'), vs);

		var filterConceptFactory = new facete.ConceptFactoryConst(conceptFalse)
		

		
		$scope.facetTreePluginContext = {
			toggleTableLink: function(path) {
			    //var active = $scope.active;
			    var active = $scope;
			    
               	if(active.facetTableConfig) {
               	    active.facetTableConfig.togglePath(path);
               	}
               	
//                	if(active.allFacetTableConfig) {
//                	    active.allFacetTableConfig.togglePath(path);
//                	}
			}
		};


		$scope.facetTreePlugins = ['<a ng-show="data.isHovered || data.item.getTags().table.isContained" href="" ng-click="context.toggleTableLink(data.item.getPath())"><span class="glyphicon glyphicon-list-alt"></span></a>'];

		
		
//         var tableMod = new facete.TableMod();
//         //tableMod.addColumn('s');
//         tableMod.addColumn('_p_');
//         tableMod.addColumn('_o_');

		
		$scope.active.sparqlService = new service.SparqlServiceDummy();
		$scope.active.geoConceptFactory = geoConceptFactory;

		
		
		refreshDataSources();
		
        $scope.active.serviceConfigs = [];
            
        var deleteThisWhenDbIsDone =
        [
			{        
		        name: 'FP7 ICT Project Partners (local)',
		        dataService: {
		            serviceIri: 'http://localhost/data/fp7-pp/sparql',
		            defaultGraphIris: ['http://fp7-pp.publicdata.eu/']
		        },
		        joinSummaryService: {
		            serviceIri: null,
		            defaultGraphIris: []
		        },
		        conceptPathFinderApiUrl: 'api/path-finding',        
		        facetTreeConfig: facetTreeConfig,
		        mapConfig: {
		            mapFactory: geo.GeoMapFactoryUtils.wgs84MapFactory,
		            geoConcept: geo.GeoConcepts.conceptWgs84,
					quadTreeConfig: {
						maxItemsPerTileCount: 1000,
						maxGlobalItemCount: 2000
					}
				}
			},
			{
            name: 'Freebase Germany (local)',
            dataService: {
                serviceIri: 'http://localhost/data/freebase/germany/sparql',
                defaultGraphIris: ['http://freebase.com/2013-09-22/data/']
            },
            joinSummaryService: {
                serviceIri: null,
                defaultGraphIris: []
            },
            conceptPathFinderApiUrl: 'api/path-finding',
            facetTreeConfig: facetTreeConfig,
            mapConfig: {
                mapFactory: geo.GeoMapFactoryUtils.wgs84MapFactory,
                geoConcept: geo.GeoConcepts.conceptWgs84,
			    quadTreeConfig: {
					maxItemsPerTileCount: 1000,
					maxGlobalItemCount: 2000
				}
            }
        },
        {
            name: 'GeoStats (local)',
            dataService: {
                serviceIri: 'http://localhost/data/geostats/sparql',
                defaultGraphIris: ['http://localhost/geostats.nt']
            },
            joinSummaryService: {
                serviceIri: null,
                defaultGraphIris: []
            },
            conceptPathFinderApiUrl: 'api/path-finding',
            facetTreeConfig: facetTreeConfig,
            mapConfig: {
                mapFactory: geo.GeoMapFactoryUtils.ogcVirtMapFactory,
                geoConcept: geo.GeoConcepts.conceptGeoVocab,
			    quadTreeConfig: {
					maxItemsPerTileCount: 1000,
					maxGlobalItemCount: 2000
				}
            }
        },
        {        
            name: 'DBpedia, geo & types (local)',
            dataService: {
                serviceIri: 'http://localhost/data/dbpedia/3.9/sparql',
                defaultGraphIris: ['http://dbpedia.org/3.9/']
            },
            joinSummaryService: {
                serviceIri: null,
                defaultGraphIris: []
            },
            conceptPathFinderApiUrl: 'api/path-finding',        
            facetTreeConfig: facetTreeConfig,
            mapConfig: {
                mapFactory: geo.GeoMapFactoryUtils.wgs84MapFactory,
                geoConcept: geo.GeoConcepts.conceptWgs84,
			    quadTreeConfig: {
					maxItemsPerTileCount: 1000,
					maxGlobalItemCount: 2000
				}
            }
        },
        {
            name: 'GeoKnow Y1 Demo Dataset (local)',
            dataService: {
                serviceIri: 'http://localhost/data/geoknow/demo/y1/sparql',
                defaultGraphIris: []
            },
            joinSummaryService: {
                serviceIri: null,
                defaultGraphIris: []
            },
            conceptPathFinderApiUrl: 'api/path-finding',
            facetTreeConfig: facetTreeConfig,
            mapConfig: {
                mapFactory: geo.GeoMapFactoryUtils.wgs84MapFactory,
                geoConcept: geo.GeoConcepts.conceptWgs84,
			    quadTreeConfig: {
					maxItemsPerTileCount: 1000,
					maxGlobalItemCount: 2000
				}
            }
        },
        {        
            name: 'FP7 ICT Project Partners (remote)',
            dataService: {
                serviceIri: 'http://fp7-pp.publicdata.eu/sparql',
                defaultGraphIris: ['http://fp7-pp.publicdata.eu/']
            },
            joinSummaryService: {
                serviceIri: null,
                defaultGraphIris: []
            },
            conceptPathFinderApiUrl: 'api/path-finding',        
            facetTreeConfig: facetTreeConfig,
            mapConfig: {
                mapFactory: geo.GeoMapFactoryUtils.wgs84MapFactory,
                geoConcept: geo.GeoConcepts.conceptWgs84,
			    quadTreeConfig: {
					maxItemsPerTileCount: 1000,
					maxGlobalItemCount: 2000
				}
            }
        },
//         {
//             name: 'GeoKnow Demo Dataset (remote)',
//             dataService: {
//                 serviceIri: 'http://cstadler.aksw.org/geoknow/sparql',
//                 defaultGraphIris: []
//             },
//             joinSummaryService: {
//                 serviceIri: null,
//                 defaultGraphIris: []
//             },
//             conceptPathFinderApiUrl: 'api/path-finding',
//             facetTreeConfig: facetTreeConfig,
//             mapConfig: {
//                 mapFactory: geo.GeoMapFactoryUtils.wgs84MapFactory,
//                 geoConcept: geo.GeoConcepts.conceptWgs84,
// 			    quadTreeConfig: {
// 					maxItemsPerTileCount: 1000,
// 					maxGlobalItemCount: 2000
// 				}
//             }
//         },
        {        
            name: 'DBpedia, official (remote)',
            dataService: {
                serviceIri: 'http://dbpedia.org/sparql',
                defaultGraphIris: ['http://dbpedia.org']
            },
            joinSummaryService: {
                serviceIri: 'http://cstadler.aksw.org/service/join-summary/sparql',
                defaultGraphIris: ['http://dbpedia.org/2013-12-22/join-summary-essential/']
            },
            conceptPathFinderApiUrl: 'api/path-finding',        
            facetTreeConfig: facetTreeConfig,
            mapConfig: {
                mapFactory: geo.GeoMapFactoryUtils.wgs84MapFactory,
                geoConcept: geo.GeoConcepts.conceptWgs84,
			    quadTreeConfig: {
					maxItemsPerTileCount: 1000,
					maxGlobalItemCount: 2000
				}
            }
        },
        {
            name: 'LinkedGeoData (remote)',
            dataService: {
                serviceIri: 'http://linkedgeodata.org/sparql',
                defaultGraphIris: ['http://linkedgeodata.org']
            },
            joinSummaryService: {
                serviceIri: 'http://linkedgeodata.org/join-summary/sparql',
                defaultGraphIris: ['http://linkedgeodata.org/join-summary']
            },
            conceptPathFinderApiUrl: 'api/path-finding',
            facetTreeConfig: facetTreeConfig,
            mapConfig: {
                mapFactory: geo.GeoMapFactoryUtils.wgs84MapFactory,
                geoConcept: geo.GeoConcepts.conceptWgs84,
			    quadTreeConfig: {
					maxItemsPerTileCount: 1000,
					maxGlobalItemCount: 2000
				}
            }
        }
//         {
//             name: 'GeoStats (remote)',
//             dataService: {
//                 serviceIri: 'http://cstadler.aksw.org/service/geostats/sparql',
//                 defaultGraphIris: ['http://geostats.aksw.org/']
//             },
//             joinSummaryService: {
//                 serviceIri: null,
//                 defaultGraphIris: []
//             },
//             conceptPathFinderApiUrl: 'api/path-finding',
//             facetTreeConfig: facetTreeConfig,
//             mapConfig: {
//                 mapFactory: geo.GeoMapFactoryUtils.ogcVirtMapFactory,
//                 geoConcept: geo.GeoConcepts.conceptGeoVocab,
// 			    quadTreeConfig: {
// 					maxItemsPerTileCount: 1000,
// 					maxGlobalItemCount: 2000
// 				}
//             }
//         },
//         {
//             name: 'LGD Sparqlify Localhost',
//             dataService: {
//                 serviceIri: 'http://localhost:7531/sparql',
//                 defaultGraphIris: []
//             },
//             joinSummaryService: {
//                 serviceIri: 'http://linkedgeodata.org/join-summary/sparql',
//                 defaultGraphIris: ['http://linkedgeodata.org/join-summary']
//             },
//             conceptPathFinderApiUrl: 'api/path-finding',
//             facetTreeConfig: facetTreeConfig,
//             mapConfig: {
//                 mapFactory: geo.GeoMapFactoryUtils.wgs84MapFactory,
//                 geoConcept: geo.GeoConcepts.conceptWgs84,
// 			    quadTreeConfig: {
// 					maxItemsPerTileCount: 1000,
// 					maxGlobalItemCount: 2000
// 				}
//             }
        ];

        
        /**
         * Init of derived attributes
         *
         */
         
//        _($scope.active.serviceConfigs).each(function(serviceConfig) {
            // Create the facetTableConfig
// 			var facetTreeConfig = serviceConfig.facetTreeConfig;
//             var facetConfig = facetTreeConfig.getFacetConfig()


//            serviceConfig.facetTableConfig = facetTableConfig;

            // Init the taggerMap
//     		var pathTaggerManager = facetConfig.getPathTaggerManager()
//     		var taggerMap = pathTaggerManager.getTaggerMap();
    		
//     		taggerMap.table = new facete.ItemTaggerMembership(facetTableConfig.getPaths());
    		
    		// Init the tableMod
//     		var tableMod = facetTableConfig.getTableMod();
//     		tableMod.addColumn('s');
//        });

        
        $scope.active.path = null;

		
		/*
		 * Concept Path Finding
		 */
		var refresh = function(config) {
			
		    var conceptPathFinderApiUrl = config.conceptPathFinderApiUrl;
		    var sparqlServiceIri = config.dataService.serviceIri;
		    var defaultGraphIris = config.dataService.defaultGraphIris;
		    var joinSummaryServiceIri = config.joinSummaryService.serviceIri;
		    var joinSummaryDefaultGraphIris = config.joinSummaryService.defaultGraphIris;
		    
		    
		    var geoConcept = config.mapConfig.geoConcept;
		    
		    var conceptPathFinder = new client.ConceptPathFinderApi(conceptPathFinderApiUrl, sparqlServiceIri, defaultGraphIris, joinSummaryServiceIri, joinSummaryDefaultGraphIris);

            var facetTreeConfig = config.facetTreeConfig;
    		var conceptFactory = new facete.ConceptFactoryFacetTreeConfig(facetTreeConfig);

		    
		    var sourceConcept = conceptFactory.createConcept(); 	
			var targetConcept = geoConcept;
								
			
// 			var cpfSparqlService = conceptPathFinder.createSparqlService(sourceConcept, targetConcept);
// 			var qe = cpfSparqlService.createQueryExecution('Select * { ?s ?p ?o } Limit 10');
// 			qe.execSelect().done(function(rs) {
// 				alert(JSON.stringify(rs.getBindings()));
// 			}).fail(function() {
// 			    alert('fail');
// 			});
			
			
		    var promise = conceptPathFinder.findPaths(sourceConcept, targetConcept);
			var result = sponate.angular.bridgePromise(promise, $q.defer(), $rootScope);
	
			result.then(function(paths) {
			    var tmp = _(paths).map(function(path) {

			        var pathName = path.toString();
			        if(pathName === '') {
			            pathName = '(empty path)';
			        }

			        var r = {
						name: pathName,
						path: path
					};
			        return r;
			    });
			   
			    $scope.active.geoPaths = tmp;
			}, function(err) {
			    alert(err.responseText);
			});
		};
		        
       	var refreshServices = function(config) {
       	    if(!config) {
				return;
       	    }

            var dataCnf = config.dataService;

            var facetTreeConfig = config.facetTreeConfig;
            
    		var sparqlService = new service.SparqlServiceHttp('cache/sparql', dataCnf.defaultGraphIris, {}, {'service-uri': dataCnf.serviceIri});

    		sparqlService = new service.SparqlServiceCache(sparqlService);
    		sparqlService = new service.SparqlServicePaginate(sparqlService, 1000);

//     		debugger;    		
//     		var query = new sparql.Query();
//     		query.getElements().push(new sparql.ElementTriplesBlock([new rdf.Triple(rdf.NodeFactory.createVar('s'), rdf.NodeFactory.createVar('p'), rdf.NodeFactory.createVar('o'))]));
//     		query.setResultStar(true);
//     		query.setLimit(10);    		
//     		sparqlService.createQueryExecution(query).execSelect().done(function(rs) {
//     		    var hash = Jassa.util.ObjectUtils.hashCode(sparqlService);
//     			alert(hash);
//     		});

    		
    		var conceptFactory = new facete.ConceptFactoryFacetTreeConfig(facetTreeConfig);


    		//var mapFactory =  geo.GeoMapFactoryUtils.ogcVirtMapFactory;
    		var mapFactory = config.mapFactory;
    		    		
    		$scope.active.sparqlService = sparqlService;		
            $scope.active.facetTreeConfig = facetTreeConfig;
            
            //$scope.path = null;

            /*
            var facetConfig = facetTreeConfig.getFacetConfig();
    		var facetConceptFactory = new facete.ConceptFactoryFacetConfig(facetConfig);

            var dataConcept = facete.ConceptUtils.createSubjectConcept(vs);
            var elementFactory = new sparql.ElementFactoryJoinConcept(new facete.ConceptFactoryConst(dataConcept), filterConceptFactory);
                
            var queryFactory = new facete.QueryFactoryTableMod(elementFactory, tableMod);

    		$scope.active.facetTableConfig = {
    			queryFactory: queryFactory,
    			tableMod: tableMod
    		};
            */

            
    		/*
    		 * <- Facet Tree 'Link-Facet-To-Table' Plugin
    		 */
    		var facetConfig = facetTreeConfig.getFacetConfig()
            var facetTableConfig = config.facetTableConfig;
    		var tableMod = facetTableConfig.getTableMod();

    		
            var dataConcept = facetTableConfig.createDataConcept();
            var dataElementFactory = new sparql.ElementFactoryConst(dataConcept.getElement());
            
            var filterElementFactory = new facete.ElementFactoryConceptFactory(filterConceptFactory);
            
            
            //var filterConcept = filterConceptFactory.createConcept();
            
            //debugger;
            // NOTE We assume the data and filter concept share the same variables
            var elementFactory = new sparql.ElementFactoryCombine(true, [dataElementFactory, filterElementFactory]);
            //var element = tmp.flatten();
            
            //console.log('EEEEEEEelement: ' + element);
            
            //var elementFactory = new sparql.ElementFactoryConst(element);
            //var elementFactory = new sparql.ElementFactoryJoinConcept(new facete.ConceptFactoryConst(dataConcept), filterConceptFactory);           
            var queryFactory = new facete.QueryFactoryTableMod(elementFactory, tableMod);

    		$scope.active.facetTableConfig = {
    			queryFactory: queryFactory,
    			tableMod: tableMod
    		};
    		

            var allQueryFactory = new facete.QueryFactoryTableMod(dataElementFactory, tableMod);

    		$scope.active.allFacetTableConfig = {
    		    queryFactory: allQueryFactory,
    		    tableMod: tableMod
    		};
    		
    		
    		// HACK! because of name clash in .active
    		$scope.facetTableConfig = facetTableConfig;
    		//$scope.allFacetTableConfig = $scope.active.allFacetTableConfig;
    		/*
    		 * ->
    		 */
            

            
            
            
    		var mapConfig = config.mapConfig;
    		
            $scope.active.dataSources = [{
    			sparqlService: sparqlService,
    			mapFactory: mapConfig.mapFactory,
    			conceptFactory: geoConceptFactory,
    		    quadTreeConfig: mapConfig.quadTreeConfig
    		}];

        };

        $scope.active.dataSources = [];
        
        
        $scope.setDataSource = function(item) {
            alert(JSON.stringify(item));
        };
        
//         $scope.$watch('dataSourceSelection.active', function(val) {
// 			alert(JSON.stringify(val));
//         });

		$scope.ObjectUtils = util.ObjectUtils;
		
		
		//$scope.$watch('ObjectUtils.hashCode(facetTreeConfig)', function() {
		//$scope.$watch('ObjectUtils.hashCode(active.service)', function() {

		// Important: We should only refresh the services if the *reference* to
		// the config object changes - it doesn't make sense to refresh if an internal config
		// parameter changes, as we would keep refreshing
		$scope.$watch('active.service', function() {
		    var config = $scope.active.service;
		    if(config) {
		    	refreshServices(config);
		    	refresh(config);
		    }
		});
		
		
		var serviceConfigs = $scope.active.serviceConfigs
        $scope.active.service = serviceConfigs.length === 0 ? null : serviceConfigs[0];


		
		$scope.setGeoPath = function(path) {
		    $scope.active.geoConceptFactory.setPath(path);
		};

        $scope.selectFacet = function(path) {
            $scope.active.path = path;
        };

        $scope.selectGeom = function(data) {
            console.log('Data selected: ', data);
        
            var geoConceptFactory = data.config.conceptFactory;
            
            var geoConcept = geoConceptFactory.createConcept();
            var vs = geoConcept.getVar();
            var rootVar = geoConceptFactory.getFacetTreeConfig().getFacetConfig().getBaseConcept().getVar();
            
            
           	//alert('Select: ' + JSON.stringify(data));
			var node = data.id;
            var ev = new sparql.ExprVar(vs);
            var nodeValue = sparql.NodeValue.makeNode(node);
            var expr = new sparql.E_Equals(ev, nodeValue);
            var elementFilter = new sparql.ElementFilter(expr);
            
            var elements = geoConcept.getElements().slice(0);
            elements.push(elementFilter);
            
            
			var concept = facete.Concept.createFromElements(elements, rootVar);

			//alert('SelectConcept: ' + concept);
			
			filterConceptFactory.setConcept(concept);

			if(!$scope.$$phase) {
                $scope.$apply();
            }
        }

        $scope.unselectGeom = function(data) {
            //alert('Unselect: ' + JSON.stringify(data));
			filterConceptFactory.setConcept(conceptFalse);
			if(!$scope.$$phase) {
                $scope.$apply();
            }
        }


        
        $scope.nextConceptSpaceId = 1;
        $scope.conceptSpaces = [];
        
        
        $scope.addConceptSpace = function() {
            var conceptSpaceId = '' + ($scope.nextConceptSpaceId++);
            
            var conceptSpaceName = 'concept-' + conceptSpaceId;
            
            if(conceptSpaceId === '1') {
				conceptSpaceName = 'Hotels @ DBpedia';
            }

            if(conceptSpaceId === '2') {
				conceptSpaceName = 'Hotels @ Wikimapia';
            }

            if(conceptSpaceId === '3') {
				conceptSpaceName = 'Airports @ Freebase';
            }

			var config = {
			    id: conceptSpaceId,
			    name: conceptSpaceName
			};
			
			$scope.conceptSpaces.push(config);
        };
        
        $scope.selectConceptSpace = function(index) {
			_($scope.conceptSpaces).each(function(conceptSpace) {
				conceptSpace.active = false;
			});
			
			$scope.conceptSpaces[index].active = true;
        };
        
        $scope.removeConceptSpace = function(index) {
			$scope.conceptSpaces.splice(index, 1);
        };
        
        
        $scope.searchResults = [];
        
        $scope.doSearch = function(searchString) {
            $scope.app.search.show = true;
            $scope.app.search.isOpen = true;
            
            var ajaxSpec = {
				crossDomain: true,
				url: 'http://nominatim.openstreetmap.org/search/',
				dataType: 'json',
				traditional: 'true',
				data: {
				    format: 'json',
					q: searchString
				}
            };
            
            var promise = jQuery.ajax(ajaxSpec).pipe(function(items) {
                _(items).each(function(item) {
                    var nameParts = item.display_name.split(',');
                    
                    item.primaryName = nameParts[0];
                    item.description = nameParts[1];
                });

                return items;
            });
            
			sponate.angular.bridgePromise(promise, $q.defer(), $rootScope, function(data) {
			    $scope.searchResults = data;
			});
        };
        
        $scope.active.mapConfig = {};
        
        $scope.selectSearchResult = function(item) {
			$scope.active.mapConfig.center = {lon: item.lon, lat: item.lat},
			$scope.active.mapConfig.zoom = 13;
        };

        
        $scope.notifications = [];
        
        
        
        var applyRootScope = function(scope) {
            var rootScope = scope.$root;

            if(!rootScope.$$phase) {
                rootScope.$apply()
            }
        };
        
        
        
        var metaPrefixes = {
			'rdfs': 'http://www.w3.org/2000/01/rdf-schema#',
            'batch': 'http://ns.aksw.org/spring/batch/'
        };
    	var metaSparqlService = new service.SparqlServiceHttp('api/export-status/sparql', []);	
    	var metaStore = new sponate.StoreFacade(metaSparqlService, metaPrefixes);
    	
   		metaStore.addMap({
   			name: 'sparqlExports',
   			template: [{
   				id: '?je',
   				context: '?jec',
   				exitCode: '?jeec',
   				status: '?jes',
   				steps: [{
   					id: '?se',
   					label: '?sel',
   					context: '?sec'
   				}]
   			}],
   			from:
'{ Select ?je ?jeec ?jes ?jec ?se ?sel ?sec {\
  ?je\
    a batch:JobExecution ;\
    batch:exitCode ?jeec ;\
    batch:status ?jes ;\
    batch:shortContext ?jec ;\
    batch:stepExecution ?se .\
\
  ?se\
    rdfs:label ?sel ;\
    batch:shortContext ?sec .\
} }'
   		});
       
   		
   		/**
   		 * Index the map of a spring batch object
   		 */
   		var indexBatchMap = function(map) {
   		    var result;
   		    var entry = map ? map.entry : null;
   		    
   		    if(!entry) {
   		        result = {};
   		    }
   		    else if(_(entry).isArray()) {
				result = _(entry).indexBy('string');
			}
   		    else {
				result = {};
				var key = entry['string'];
				result[key] = entry;
   		    }
   		    
   		    return result;
   		}
        
   		
   		var processJobStatus = function(item) {
		    var jobContext = JSON.parse(item.context);

			var jobMap = indexBatchMap(jobContext.map);
			console.log(jobMap); 

			var tmp = jobMap['DataCountTasklet.count'];
			var countStr = tmp ? tmp['long'] : null; 
			    
			    
			var maxItemCount = countStr != null ? parseInt(countStr) : null;
			var itemCount = 0;
		    
		    _(item.steps).each(function(step) {
				if(step.label === 'dataFetchStep') {
				    var stepContext = JSON.parse(step.context);
				    var stepMap = indexBatchMap(stepContext.map);
				    
					itemCount = parseInt(stepMap['FlatFileItemWriter.written']['long']);
				}
		    });
		    
		    var isRunning = item.status !== 'STOPPED' && item.status !== 'COMPLETED' && item.status !== 'FAILED'; 
		    
		    var result = {
		        id: item.id.slice(1, -1),
		        isRunning: isRunning,
		        isCounting: isRunning && maxItemCount == null,
		        isRetrieving: isRunning && maxItemCount != null,
		        isFinished: !isRunning,
		        isFailed: !isRunning && item.exitCode !== 'COMPLETED',
		        isSucceeded: !isRunning && item.exitCode === 'COMPLETED',
		        progress: {
		            current: itemCount,
					max: maxItemCount,
					percentage: (maxItemCount != null) ? Math.floor(itemCount / maxItemCount * 100) : 0
		        }
		    };
		    
		    //alert(JSON.stringify(result));
			
		    
		    return result;
   		};


        var watchExport = function(jobExecutionUri, status) {
            var v = rdf.NodeFactory.createVar('je');
            var elementFilter = new sparql.ElementFilter(new sparql.E_Equals(new sparql.ExprVar(v), sparql.NodeValue.makeNode(rdf.NodeFactory.createUri(jobExecutionUri))));
            
            var element = new sparql.ElementGroup([
				new sparql.ElementTriplesBlock([
					new rdf.Triple(v, rdf.NodeFactory.createVar('ppp'), rdf.NodeFactory.createVar('ooo'))
				]),
				elementFilter
			]);
            
            var concept = new facete.Concept(element, v);
	
			var promise = metaStore.sparqlExports.find().concept(concept).asList();
			promise.done(function(data) {
			    
			    var item = data[0];
				
			    //alert('yay' + JSON.stringify(item));
			    
			    var jobStatus = processJobStatus(item);
			    
		        status.jobStatus = jobStatus;		        
                applyRootScope($scope);

				console.log('Still alive: ', jobStatus.isRunning);

			    if(jobStatus.isRunning) {
				    setTimeout(function() {				        
				        watchExport(jobExecutionUri, status);
				    }, 3000);
			    }

			}).fail(function() {
			    alert('fail');
			});
        }
        
        $scope.exportAll = function() {
            var queryFactory = $scope.active.allFacetTableConfig.queryFactory;
            var query = queryFactory.createQuery();
            //alert('' + query);

            var status = {
				msg: 'Export started.'
            };
            
            $scope.notifications.push(status);
                //applyRootScope($scope);

            
            var config = $scope.active.service;
            
            var promise = jQuery.ajax({
            	url: 'api/export/start',
            	traditional: true,
            	data: {
            	    'service-uri': config.dataService.serviceIri,
            		'default-graph-uri': config.dataService.defaultGraphIris,
            	    query: '' + query
            	}
            });
            
            promise.done(function(data) {
                //$scope.notifications.push({msg: 'Export successfully started: ' + data.id});
                status.msg = 'Export successfully started: ' + data.id;
               	applyRootScope($scope);
                
                watchExport(data.id, status);
                
            }).fail(function() {
                status.msg = 'Export failed: '; // + data.id;
               	applyRootScope($scope);
            })
        }
        
        
        

    }]);
	</script>

</head>

<body ng-controller="MyCtrl">

	<nav class="navbar navbar-default" role="navigation">
		<div class="container-fluid">
			<!-- Brand and toggle get grouped for better mobile display -->
   			<div class="navbar-header">
				<button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
					<span class="sr-only">Toggle navigation</span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
				</button>
				
				<a class="navbar-brand" style="padding: 3px 15px;" href="#"><img style="height: 42px;" src="images/logo-eccenca-plain.png" alt=""></img></a>
				<a class="navbar-brand" href="#">Facete II</a>
			</div>

			<div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
				 <form class="navbar-form navbar-left" role="search">
	        		<div class="form-group">
	          			<input type="text" ng-model="app.searchString" class="form-control" placeholder="Find Place...">
	        		</div>
	        		<button type="submit" ng-click="doSearch(app.searchString)" class="btn btn-default">Submit</button>
				</form>

<!-- 				<ul class="nav navbar-nav"> -->
<!-- 					<li class="dropdown"><a href="#" class="dropdown-toggle" -->
<!-- 						data-toggle="dropdown">Tools <b class="caret"></b></a> -->
<!-- 						<ul class="dropdown-menu"> -->
<!-- 							<li><a href="#">Interlinking</a></li> -->
<!-- 							<li><a href="#">Fusion</a></li> -->
<!-- 						</ul></li> -->
<!-- 				</ul> -->

				<ul class="nav nav-pills navbar-nav navbar-right">
					<li class="dropdown" ng-class="{'active': (notifications.length > 0)}">
						<a href="#" class="dropdown-toggle" data-toggle="dropdown">Notifications <span class="badge">{{notifications.length}}</span> <b class="caret"></b></a>
						<ul class="dropdown-menu">
							<li ng-if="!(notifications.length > 0)">(empty list)</li>
							<li ng-repeat="item in notifications | reverse">
								<div style="border-style:solid; border-color: #eeeeee; border-width: 1px; margin: 5px; padding: 5px; width: 250px;">
									<b ng-if="item.jobStatus.isCounting">Preparing export (counting)...</b>
									<b ng-if="item.jobStatus.isRetrieving">Preparing export (retrieving)...</b>
									<b ng-if="item.jobStatus.isSucceeded">Export succeeded.</b>
									<b ng-if="item.jobStatus.isFailed">Export failed.</b>
									<a ng-if="item.jobStatus.isSucceeded" class="btn btn-primary btn-large" target="_blank" style="width: 50%"href="api/export/retrieve?id={{item.jobStatus.id}}&format=csv">CSV</a>
									<a ng-if="item.jobStatus.isSucceeded" class="btn btn-primary btn-large" target="_blank" style="width: 50%"href="api/export/retrieve?id={{item.jobStatus.id}}&format=xml">XML</a>
									<progressbar class="active" ng-class="{'progress-striped': item.jobStatus.isRunning}" animate="true" value="item.jobStatus.progress.percentage" type="{{(item.jobStatus.isRunning || item.jobStatus.isSucceeded) ? 'success' : 'danger'}}"><b>{{item.jobStatus.progress.percentage}}%</b></progressbar>
									<span>Processed {{item.jobStatus.progress.current || '0'}} / {{item.jobStatus.progress.max || '?'}} items.</span>
<!-- 								<progressbar class="active progress-striped" ng-class="{'': item.jobStatus.isRunning}" animate="true" value="50" max="100" type="success"><b>50%</b></progressbar> -->
							
								</div>
								<!-- <a href="">{{item}}</a>  -->
								<!-- For now we support only export {started, cancelled, failed and finished} -->
							</li>
<!-- 							<li><a href="#">Action</a></li> -->
<!-- 							<li><a href="#">Another action</a></li> -->
<!-- 							<li><a href="#">Something else here</a></li> -->
<!-- 							<li class="divider"></li> -->
<!-- 							<li><a href="#">Separated link</a></li> -->
						</ul>
					</li>
				</ul>

			</div>
							
<!-- 			<div class="collapse navbar-collapse"> -->
<!--       			<ul class="nav navbar-nav"> -->
<!--         			<li class="active"><a href="#">Source Code</a></li> -->
<!--         			<li><a href="#">Link</a></li> -->
<!--         		</ul> -->
<!--         	</div> -->
		</div>
	</nav>

	<div style="position: absolute; top: 50px; left: 0px; width: 500px; bottom: 0px; overflow: auto; padding: 5px; pointer-events:none">


		<accordion close-others="false">

			<accordion-group style="pointer-events: auto;" ng-if="app.search.show" is-open="app.search.isOpen">
				<accordion-heading>
					<i class="glyphicon" ng-class="{'glyphicon-chevron-down': app.search.isOpen, 'glyphicon-chevron-right': !app.search.isOpen}"></i>
					Search Results
					<a href="" ng-click="app.search.show = false"><span class="glyphicon glyphicon-remove-circle"></span></a>
				</accordion-heading>
				
				<ul>
				<li ng-show="!(searchResults.length > 0)">(this list is empty)</li>
				<li ng-repeat="item in searchResults">
					<a href="" ng-click="selectSearchResult(item)"><b>{{item.primaryName}}</b></a>
					<span>{{item.description}}</span>
				</li>
				</ul>
			</accordion-group>
		
			<accordion-group style="pointer-events: auto;" is-open="app.dataSources.isOpen">
				<accordion-heading>
					<i class="glyphicon" ng-class="{'glyphicon-chevron-down': app.dataSources.isOpen, 'glyphicon-chevron-right': !app.dataSources.isOpen}"></i>
					Data Sources {{active.service ? '[' + active.service.name + ']': ''}}
				</accordion-heading>

				<select ng-model="active.service" ng-options="item.name for item in active.serviceConfigs"></select>

				<br />
				<button class="btn btn-primary" ng-class="{'active': app.dataSources.showAddDialog}" ng-click="app.dataSources.showAddDialog=!app.dataSources.showAddDialog">Add Data Source</button>
				<button ng-if="active.service" class="btn" ng-click="deleteDataSource(active.service.id)">Delete Selected Data Source</button>
				
			</accordion-group>

<!-- 			<accordion-group style="pointer-events: auto;" is-open="isOpenConcepts"> -->
<!-- 				<accordion-heading> -->
<!-- 					<i class="glyphicon" ng-class="{'glyphicon-chevron-down': isOpenConcepts, 'glyphicon-chevron-right': !isOpenConcepts}"></i> -->
<!-- 					Concepts {{active.service ? '[' + active.service.name + ']': ''}} -->
<!-- 				</accordion-heading> -->
				
<!-- 				<ul> -->
<!-- 			    	<li ng-show="conceptSpaces.length == 0" class="inactive">(there are no concepts yet)</li> -->
<!-- 				    <li ng-repeat="conceptSpace in conceptSpaces" ng-class="{'highlite': conceptSpace.active}"> -->
<!-- 				    	<a href="" ng-click="removeConceptSpace($index)"><span class="glyphicon glyphicon-remove-circle"></span></a> -->
<!-- 				    	<a href="" ng-click="selectConceptSpace($index)">{{conceptSpace.name}}</a> -->
<!-- 				   	</li> -->
<!-- 				</ul> -->
				
<!-- 				<button class="btn btn-primary" ng-click="addConceptSpace()">Create a new Concept</button> -->
<!-- 			</accordion-group> -->

			<accordion-group class="portlet" style="pointer-events: auto;" is-open="app.geoLinks.isOpen">
				<accordion-heading>
					<i class="glyphicon" ng-class="{'glyphicon-chevron-down': app.geoLinks.isOpen, 'glyphicon-chevron-right': !app.geoLinks.isOpen}"></i>
					GeoLinks
				</accordion-heading>

				<tabset>
					<tab heading="Candidates">
		   				<ul>
		   					<li ng-repeat="geoPath in active.geoPaths">
		   						<a href="" ng-click="setGeoPath(geoPath.path)">{{geoPath.name}}</a>
		   					</li>
		   				</ul>
				  	</tab>
					<tab heading="Active">
						To be done
					</tab>
				</tabset>
			</accordion-group>

			<accordion-group style="pointer-events: auto;" is-open="app.facets.isOpen">
				<accordion-heading>
					<i class="glyphicon" ng-class="{'glyphicon-chevron-down': app.facets.isOpen, 'glyphicon-chevron-right': !app.facets.isOpen}"></i>
					Facets
				</accordion-heading>

				<div class="panel panel-info"> 
					<div class="panel-heading portlet-heading">
						Facet Tree
					</div>
					<div class="panel-body">
					   <facet-tree sparql-service="active.sparqlService" facet-tree-config="active.facetTreeConfig" select="selectFacet(path)" plugins="facetTreePlugins" plugin-context="facetTreePluginContext"></facet-tree>
					</div>
				</div>
		
				<div class="panel panel-info"> 
					<div class="panel-heading portlet-heading">
						Facet Values
					</div>
					<div class="panel-body">
		   				<facet-value-list sparql-service="active.sparqlService" facet-tree-config="active.facetTreeConfig" path="active.path"></facet-value-list>
					</div>
				</div>
		
				<div class="panel panel-info"> 
					<div class="panel-heading portlet-heading">
						Constraints
					</div>
					<div class="panel-body">
		   				<constraint-list sparql-service="active.sparqlService" facet-tree-config="active.facetTreeConfig"></constraint-list>
					</div>
				</div>
			</accordion-group>
		</accordion>

	</div>


	<div style="position: absolute; margin: 0px; bottom: 20px; left: 530px; top: 50px; right: 5px; overflow: auto; pointer-events: none;">

		<accordion style="background-color: white; position: absolute; bottom: 0px; left: 0px; max-height: 100%; min-height: 50px; min-width: 50px; pointer-events: auto;" resizable="resizableConfig" bounds="app.data.bounds" ng-style="!app.data.isOpen && {width: '', height: ''}">
			<accordion-group is-open="app.data.isOpen">
				<accordion-heading>
					<i class="glyphicon" ng-class="{'glyphicon-chevron-down': app.data.isOpen, 'glyphicon-chevron-right': !app.data.isOpen}"></i>
					Data
				</accordion-heading>
			
				<tabset>
					<tab heading="All">
						<button class="btn btn-primary" ng-click="exportAll()">Export</button>
						<sparql-table sparql-service="active.sparqlService" config="active.allFacetTableConfig"></sparql-table>
					</tab>
		
					<tab heading="Selection">
						<sparql-table sparql-service="active.sparqlService" config="active.facetTableConfig"></sparql-table>
					</tab>


<!-- 					<tab heading="Interlinking"> -->
<!-- 						<form class="well form-horizontal"> -->
<!-- 							<div class="form-group"> -->
<!-- 								<label>Source Concept: <input ng-model="edit.name" type="text" class="form-control"></input></label> -->
<!-- 							</div> -->
<!-- 							<div class="form-group">					 -->
<!-- 								<label>Target Concept: <input ng-model="edit.dataServiceIri" type="text" class="form-control"></input></label> -->
<!-- 							</div> -->
<!-- 							<button class="btn btn-primary" ng-click="hideCreateDataSource=true">Cancel</button> -->
<!-- 							<button class="btn btn-primary" ng-click="addDataSource()">Confirm</button>			 -->
<!-- 		            	</form> -->
<!-- 					</tab> -->

				</tabset>
			</accordion-group>
		</accordion>
	</div>

	<div style="position: absolute; margin: 0px; top: 50px; left: 530px; top: 50px; overflow: auto; pointer-events: none;">
		<tabset style="pointer-events: auto;">		
			<tab ng-if="app.dataSources.showAddDialog" heading="Data Source" style="width: 500px;">

				<div style="border-style:solid; background-color:#ffffff; #eeeeee; border-width: 1px; margin: 5px; padding: 5px;">

					<form class="well form-horizontal">
						<div class="form-group">
							<label>Title: <input ng-model="edit.name" type="text" class="form-control"></input></label>
						</div>
						<div class="form-group">					
							<label>Sparql Service Iri: <input ng-model="edit.dataServiceIri" type="text" class="form-control"></input></label>
						</div>
						<div class="form-group">					
							<label>Named Graphs (Separate entries with white space): <input ng-model="edit.dataGraphIris" type="text" class="form-control"></input></label>
						</div>
						<div class="form-group">										
							<label>Join Summary Service: <input ng-model="edit.jsServiceIri" type="text" class="form-control"></input></label>
						</div>
						<div class="form-group">										
							<label>Join Summary Graphs (Separate entries with white space): <input ng-model="edit.jsGraphIris" type="text" class="form-control"></input></label>
						</div>
		
						<button class="btn btn-primary" ng-click="app.dataSources.showAddDialog=false">Cancel</button>
						<button class="btn btn-primary" ng-click="addDataSource()">Confirm</button>			
		           	</form>
				</div>
			</tab>
		</tabset>	
	</div>


    <div jassa-map-ol="map" style="position: absolute; left: 0px; top: 0px; width: 100%; height: 100%; z-index:-9999" config="active.mapConfig" sources="active.dataSources" select="selectGeom(data)" unselect="unselectGeom(data)"></div>



<!-- 	<a href="https://github.com/GeoKnow/Facete2" target="_blank"><img style="position: absolute; top: 0; right: 0; border: 0;" src="images/forkme_right_green_007200.png" alt="Fork me on GitHub"></a> -->

</body>

</html>

