<!DOCTYPE html>
<html ng-app="Facete2">

<head>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

    <title>Facete II</title>
	
    <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->
    <!-- build:css(.tmp) styles/main.css -->

    <!-- bower:css -->
    <link rel="stylesheet" href="bower_components/bootstrap/dist/css/bootstrap.css" />
    <link rel="stylesheet" href="bower_components/ng-grid/ng-grid.css" />
    <link rel="stylesheet" href="bower_components/jassa-ui-angular/jassa-ui-angular.css" />
    <link rel="stylesheet" href="bower_components/jassa-ui-angular-openlayers/jassa-ui-angular-openlayers.css" />
    <link rel="stylesheet" href="bower_components/ng-table/ng-table.css" />
    <!-- endbower -->

	<link rel="stylesheet" href="bower_components/ng-grid-bower/ng-grid.css" />
    <link rel="stylesheet" href="bower_components/jquery-ui/themes/base/jquery.ui.resizable.css" />

    <link rel="stylesheet" href="styles/facete-style.css" />

    <!-- endbuild -->

    <style>
    /* possible HACK - Move resize handles into the div, so that overflow divs don't show scrollbars because of the handle */
    /* FIXME Should not modify global css classes */
    .ui-resizable-n {
        top: 0px;
    }

    .ui-resizable-e {
        right: 0px;
    }
    
    .ui-resizable-ne {
        right: 0px;
        top: 0px;
    }

    .ui-resizable-handle:hover {
        background-color: #ddddff;
    }

    .panel-body {
        overflow: auto;
    }
/*     .panel-group { */
/*         max-height: 100%; */
/*         max-width: 100%; */
/*         overflow: auto; */
/*         position: relative;     */
/*     } */

    /*
    .tab-content {
        max-height: 100%;
        max-width: 100%;
        overflow: auto;
    }
    */
    </style>
	
    <!-- build:js scripts/scripts.js -->

    <script src="bower_components/jscache/cache.js"></script>

    <!-- bower:js -->
    <script src="bower_components/jquery/jquery.js"></script>
    <script src="bower_components/underscore/underscore.js"></script>
    <script src="bower_components/jassa/jassa.js"></script>
    <script src="bower_components/angular/angular.js"></script>
    <script src="bower_components/bootstrap/dist/js/bootstrap.js"></script>
    <script src="bower_components/ng-grid/build/ng-grid.js"></script>
    <script src="bower_components/angular-sanitize/angular-sanitize.js"></script>
    <script src="bower_components/jquery-ui/ui/jquery-ui.js"></script>
    <script src="bower_components/jassa-ui-angular/jassa-ui-angular-tpls.js"></script>
    <script src="bower_components/jassa-ui-angular-openlayers/jassa-ui-angular-openlayers-tpls.js"></script>
    <script src="bower_components/ng-table/ng-table.js"></script>
    <!-- endbower -->



	<script src="scripts/lib/ng-grid-flexible-height/ng-grid-flexible-height.js"></script>

    <script src="scripts/lib/angular-ui/0.10.0/ui-bootstrap-tpls-0.10.0.js"></script>
    <script src="bower_components/underscore.string/lib/underscore.string.js"></script>
    <script src="bower_components/openlayers/lib/OpenLayers.js"></script>

    <script src="scripts/lib/snowball/Snowball.js"></script>

    <!-- endbuild -->

<!--    <script src="js/jassa-ui-angular-geo-openlayers-tpls.js"></script> -->
	
	<script type="text/javascript">
    _.mixin(_.str.exports());


    
    var jassa = jassa || Jassa;
    
	var rdf = jassa.rdf;
	var vocab = jassa.vocab;
	var sparql = jassa.sparql;
    var service = jassa.service;
	var sponate = jassa.sponate;
    var facete = jassa.facete;
	var geo = jassa.geo;
	var util = jassa.util;
	
	var client = Jassa.client;

    var myModule = angular.module('Facete2', ['ui.bootstrap', 'ui.jassa', 'ngGrid', 'ngTable', 'ui.jassa.openlayers', 'ngSanitize'], function($rootScopeProvider) { 
        $rootScopeProvider.digestTtl(10); 
    }); 


    var ValueResolver = Class.create({
        resolve: function(value) {
            console.log('"resolve" not overridden');
            throw '"resolve" not overridden';
        },
        
        resolveAll: function(values) {
            
        }
    });
    
    var ValueResolverSponate = Class.create({
        initialize: function(store) {
            this.store = store;
        },
        
        resolve: function(value) {
            //store.node(value).find().asSingle();
        },
        
        resolveAll: function(values) {
            //store.nodes.(vaues).find.asPairs();
        }
    });
    
    
    
    
    
//  var snowball = new Snowball('english');
//  snowball.setCurrent('airports');
//  snowball.stem();
//  alert(snowball.getCurrent());

//  // Create a bif:contains qurey
//  var conceptFactory

    
    util.LabelService = Class.create({
        
    });
    
    util.LabelFetcherNode = Class.create({
        initialize: function(sponateService) { //sparqlService, labelMap) {
            this.sponateService = sponateService;
            //this.sparqlService = sparqlService;
            //this.labelMap = labelMap;
        },
        
        doesAccept: function(obj) {
            var result = _(obj.isUri).isFunction() || obj.isUri();
            return result;
        },
       
        fetchLabels: function(objs) {
            // TODO Implement
        }
    });

myModule.controller('SparqlTableCtrl', ['$scope', '$rootScope', '$q', function($scope, $rootScope, $q) {
    

    var rdf = jassa.rdf;
    var sparql = jassa.sparql;
    var service = jassa.service;
    var util = jassa.util;
    var facete = jassa.facete;    
    var sponate = jassa.sponate;
    
    var syncTableMod = function(sortInfo, tableMod) {
        
        var newSortConditions = [];
        for(var i = 0; i < sortInfo.fields.length; ++i) {
            var columnId = sortInfo.fields[i];
            var dir = sortInfo.directions[i];
            
            var d = 0;
            if(dir === 'asc') {
                d = 1;
            }
            else if(dir === 'desc') {
                d = -1;
            }
            
            if(d !== 0) {
                var sortCondition = new facete.SortCondition(columnId, d);
                newSortConditions.push(sortCondition);
            }
        }

        var oldSortConditions = tableMod.getSortConditions();
        
        var isTheSame = _(newSortConditions).isEqual(oldSortConditions);
        if(!isTheSame) {
            util.ArrayUtils.replace(oldSortConditions, newSortConditions);
        }

    };

    
    var createTableService = function() {
        var config = $scope.config;
        
        var sparqlService = $scope.sparqlService;
        var queryFactory = config ? config.queryFactory : null;
        
        var query = queryFactory ? queryFactory.createQuery() : null;
        
        var result = new service.SparqlTableService(sparqlService, query);
        
        return result;
    };

    var sync = function() {
        var config = $scope.config;

        var tableMod = config ? config.tableMod : null;

        if(tableMod != null) {
            syncTableMod($scope.gridOptions.sortInfo, tableMod);
        }
    };

    
    $scope.$watch('gridOptions.sortInfo', function(sortInfo) {
        
        sync();
        
        $scope.refreshData();
    }, true);


    $scope.$watch('[pagingOptions, filterOptions]', function (newVal, oldVal) {
        $scope.refreshData();
    }, true);
    
    var update = function() {
        $scope.refresh();
    };
    
    
    $scope.ObjectUtils = util.ObjectUtils;
    $scope.Math = Math;

    $scope.$watch('[ObjectUtils.hashCode(config), disableRequests]', function (newVal, oldVal) {
        update();
    }, true);
    
    $scope.$watch('sparqlService', function() {
        update();
    });
    
    
    $scope.totalServerItems = 0;
        
    $scope.pagingOptions = {
        pageSizes: [10, 50, 100],
        pageSize: 10,
        currentPage: 1
    };
    
    $scope.selectPage = function() {

    };

    $scope.refresh = function() {
        var tableService = createTableService();

        if($scope.disableRequests) {
            util.ArrayUtils.clear($scope.myData);
            return;
        }
        

        $scope.refreshSchema(tableService);
        $scope.refreshPageCount(tableService);
        $scope.refreshData(tableService);
    };

    $scope.refreshSchema = function(tableService) {
        tableService = tableService || createTableService();

        var oldSchema = $scope.colDefs;
        var newSchema = tableService.getSchema();
        
        var isTheSame = _(newSchema).isEqual(oldSchema);
        if(!isTheSame) {
            $scope.colDefs = newSchema;
        }
    };

    $scope.refreshPageCount = function(tableService) {
        tableService = tableService || createTableService();
        
        var promise = tableService.fetchCount();

        jassa.sponate.angular.bridgePromise(promise, $q.defer(), $scope, function(countInfo) {
            // Note: There is also countInfo.hasMoreItems and countInfo.limit (limit where the count was cut off)
            $scope.totalServerItems = countInfo.count;
        });
    };
    
    $scope.refreshData = function(tableService) {
        tableService = tableService || createTableService();

        var page = $scope.pagingOptions.currentPage;
        var pageSize = $scope.pagingOptions.pageSize;
        
        var offset = (page - 1) * pageSize;

        
        var promise = tableService.fetchData(pageSize, offset);

        jassa.sponate.angular.bridgePromise(promise, $q.defer(), $scope, function(data) {
            var isTheSame = _(data).isEqual($scope.myData);
            if(!isTheSame) {
                $scope.myData = data;
            }
            //util.ArrayUtils.replace($scope.myData, data);
            
            // Using equals gives digest iterations exceeded errors; could be https://github.com/angular-ui/ng-grid/issues/873
            //$scope.myData = data;
        });
    };

        
//     var plugins = [];
    
//     if(ngGridFlexibleHeightPlugin) {
//         // js-hint will complain on lower case ctor call
//         var PluginCtor = ngGridFlexibleHeightPlugin;
        
//         plugins.push(new PluginCtor(30));
//     }
    
    /*
    $scope.$watch('[totalServerItems, pagingOptions.pageSize]', function(val) {
        $scope.numPages = Math.ceil($scope.totalServerItems / $scope.pagingOptions.pageSize);
    }, true);
    */
    //$scope.numPages = 10;
    $scope.maxSize = 7;
    
    $scope.myData = [];
    
    $scope.getSortDir = function(field) {
        var map = {};
        var fields = $scope.gridOptions.sortInfo.fields;
        var dirs = $scope.gridOptions.sortInfo.directions;
        
        var n = Math.max(fields.length, dirs.length);
        for(var i = 0; i < n; ++i) {
            var f = fields[i];
            var dir = dirs[i];
            
            map[f] = dir;
        }
        
        var result = map[field];
        return result;
    }

    $scope.setSortCondition = function(field, dir, append) {
        var fields = $scope.gridOptions.sortInfo.fields;
        var dirs = $scope.gridOptions.sortInfo.directions;
        
        if(!append) {
            jassa.util.ArrayUtils.replace(fields, [field]);
            jassa.util.ArrayUtils.replace(dirs, [dir]);
        } else {
            var indexes = jassa.util.ArrayUtils.indexesOf(fields, field);
            
            jassa.util.ArrayUtils.removeIndexes(fields, indexes);
            jassa.util.ArrayUtils.removeIndexes(dirs, indexes);

            fields.push(field);
            dirs.push(dir);
        }
        //alert(append);
    }
    
    $scope.gridOptions = {
        data: 'myData',
        enablePaging: true,
        useExternalSorting: true,
        showFooter: true,
        totalServerItems: 'totalServerItems',
        enableHighlighting: true,
        sortInfo: {
            fields: [],
            directions: []
            //columns: []
        },
        pagingOptions: $scope.pagingOptions,
        filterOptions: $scope.filterOptions,
        //plugins: plugins,
        columnDefs: 'colDefs'
    };

//     $scope.tableParams = new ngTableParams({
//         page: 1,            // show first page
//         count: 10           // count per page
//     }, {
//         total: data.length, // length of data
//         getData: function($defer, params) {
//             $defer.resolve(data.slice((params.page() - 1) * params.count(), params.page() * params.count()));
//         }
//     });

//     $scope.tableParams = new ngTableParams({
//         page: 1,            // show first page
//         count: 10,          // count per page
//         sorting: {
//             //name: 'asc'     // initial sorting
//         }
//     }, {
//         total: 0,           // length of data
//         getData: function($defer, params) {
//             // ajax request to api
//             Api.get(params.url(), function(data) {
//                 $timeout(function() {
//                     // update table params
//                     params.total(data.total);
//                     // set new data
//                     $defer.resolve(data.result);
//                 }, 500);
//             });
//         }
//     });
}]);

myModule.directive('sparqlTable', [function() {
    return {
        restrict: 'EA',
        replace: true,
        templateUrl: 'partials/sparql-table/sparql-table.html',
        transclude: false,
        scope: {
            sparqlService: '=',
            config: '=',
            disableRequests: '='
//            onSelect: '&select',
//            onUnselect: '&unselect'
        },
        controller: 'SparqlTableCtrl',
        link: function (scope, element, attrs) {
                
        }
    }
}]);

/**
 * Maybe this should be a generic 'object' directive...
 * A context menu would be a nice addition...
 *
 * issue: even if we have service and value, how can we deal with the case when we want labels
 * to originate from different endpoints?
 * {
 *   serviceKey: {uri, defaultGraphs},      
 *   value: new facete.Path(),   
 * } 
 *
 * The serviceKey is an additional attribute that specifies against which service to resolve the value.
 *
 * But maybe the context menu addition could be a directive on the outside???
 * e.g. <inline-context service="foo" data="bar"><object-view service="baz" data="baa"></object-view>
 */ 
myModule.directive('jassaLabel', function() {
    return {
        restrict: 'AE',
        scope: {
            service: '=',
            expr: '=',
            label: '=',
            template: '<span>{{label}}</span>'
        },
        compile: function() {
            return {
                pre: function(scope, elem, attrs) {
                    scope.on('$destroy', function() {
                        var service = scope.service;

                        if(service) {
                            service.unregister(this);
                        }                        
                    });
                    
                    scope.$watch('service', function(newService, oldService) {
                        if(oldService) {
                            oldService.unregister(this);
                        }
                        
                        if(newService) {
                            newService.register(this);
                        }
                    });
                    
                    scope.$watch('expr', function(newValue) {
                        var promise = service.request(newValue);
                        promise.then(function(label) {
                            scope.label = label;
                        });
                    });
                    
                    if(!scope.bounds) {
                        scope.bounds = {};
                    }

                    var isInitialized = false;

                    var onConfigChange = function(newConfig) {
                        //console.log('Setting config', newConfig);
                        if(isInitialized) {
                            jQuery(elem).resizable('destroy');
                        }

                        jQuery(elem).resizable(newConfig);
                        
                        isInitialized = true;
                    };
                    

                    var propNames = ['top', 'bottom', 'width', 'height'];
                    
                    var getCssPropMap = function(propNames) {
                        var data = elem.prop('style');
                        var result = _(data).pick(propNames);
                        
                        return result;
                    };
                    
                    var setCssPropMap = function(propMap) {
                        _(propMap).each(function(v, k) {
                            //console.log('css prop', k, v);
                            elem.css(k, v);
                        });
                    };

                    var bounds = getCssPropMap(propNames);
                    angular.copy(bounds, scope.bounds);
                    
                    if(scope.onResizeInit) {
                        scope.onResizeInit({
                            bounds: bounds
                        });
                    }
                    
                    var onBoundsChange = function(newBounds, oldBounds) {
                        //console.log('setting bounds', newBounds, oldBounds);
                        setCssPropMap(newBounds);
                    };
                    
                    scope.$watch('bounds', onBoundsChange, true);

                    jQuery(elem).on('resizestop', function (evt, ui) {
                        
                        var bounds = getCssPropMap(propNames);
                        angular.copy(bounds, scope.bounds);
                        //console.log('sigh', bounds);
                        
                        if (scope.onResize) {
                            scope.onResize(evt, ui, bounds);
                        }
                        
                        if(!scope.$$phase) {
                            scope.$apply();
                        }
                    });

                    scope.$watch('resizable', onConfigChange);
                    //onConfigChange(scope.resizable);
                }
            };
        }
    };
});
 
 

    
    
    sparql.ElementFactoryTransform = Class.create(sparql.ElementFactory, {
        initialize: function(baseElementFactory, fn) {
            this.baseElementFactory = baseElementFactory;
            this.fn = fn;
        },
        
        createElement: function() {
            var element = this.baseElementFactory.createElement();
            var result = this.fn(element);
            return result;
        }
    });
    
    facete.ConceptFactoryRename = Class.create(facete.ConceptFactory, {
        initialize: function(baseConceptFactory, varMap) {
            this.baseConceptFactory = baseConceptFactory;
            this.varMap = varMap;
        },
        
        createConcept: function() {
            var baseConcept = this.baseConceptFactory.createConcept();
            var v = baseConcept.getVar();
            var e = baseConcept.getElement();

            var ne = sparql.ElementUtils.createRenamedElement(e, this.varMap);
            
            var nv = this.varMap.get(v);
            if(!nv) {
                nv = v;
            }
            
            var result = new facete.Concept(ne, nv);
            return result;
        }
    });
    
    
    myModule.filter('reverse', function() {
		return function(items) {
			return items.slice().reverse();
		};
	});
    

    /*
    var test = new service.SparqlServiceHttp('http://localhost:7532/api/path-finding?service-uri=http%3A%2F%2Fcstadler.aksw.org%2Fconti%2Ffreebase%2Fgermany%2Fsparql&default-graph-uri=http%3A%2F%2Ffreebase.com%2F2013-09-22%2Fdata%2F&source-element=%3Fs+%3F_p_+%3F_o_&source-var=s&target-element=%3Fs+<http%3A%2F%2Fwww.w3.org%2F2003%2F01%2Fgeo%2Fwgs84_pos%23long>+%3Fx+%3B++<http%3A%2F%2Fwww.w3.org%2F2003%2F01%2Fgeo%2Fwgs84_pos%23lat>+%3Fy&target-var=s&js-service-uri=');
    var qe = test.createQueryExecution('Select * { ?s ?p ?o } Limit 10');
    var promise = qe.execSelect();
    promise.done(function(rs) {
       while(rs.hasNext()) {
           var binding = rs.next();
           console.log('Binding ' + binding);
       } 
    }).fail(function() {
        alert(JSON.stringify(arguments));
    });
    */

    (function() {
	    var ns = service;
	    
	    ns.QueryExecutionDummy = Class.create(ns.QueryExecution, {
	        createPromise: function(val) {
	            var deferred = jQuery.Deferred();
	            deferred.resolve(val);
	            return deferred.promise();            
	        },
	        
	        execAsk: function() {
	            var result = this.createPromise(false);
	            return result;
	        },
	        
	        execSelect: function() {
	            var rs = new ns.ResultSetArrayIteratorBinding(new util.IteratorArray([]));
	            var result = this.createPromise(rs);
	            return result;
	        },
	        
	        setTimeout: function(timeoutInMillis) {
	            
	        }
	    });
	        
	    ns.SparqlServiceDummy = Class.create(ns.SparqlService, {
	        
	        createQueryExecution: function(query) {
	            return new ns.QueryExecutionDummy();
	        },
	        
	        getStateId: function() {
	            return 'dummyId';
	        },
	        
	        getStateHash: function() {
	            return 'dummyHash';
	        },
	        
	        hashCode: function() {
	            return 'dummy-sparql-service';
	        }
	    });
    })();
    
    (function() {
	    var ns = facete;
	    ns.QueryFactoryConst = Class.create(ns.QueryFactory, {
	        initialize: function(query) {
	            this.query = query;
	        },
	        
	        createQuery: function() {
	            return this.query;
	        }
	    });
    })();
    
//     var refEquals = function(a, b) {
//         var result = a == b;
//         return result;
//     };

//     var uniqRefs = function(arr) {
//         var result = [];
//         _(arr).each(function(item) {
//             var found = _(result).find(result, refEquals);
//             if(!found) {
//                 result.push(item);
//             }
//         });
        
//         return result;
//     };
    
    var SponateLookupServiceImpl = Class.create({
        initialize: function(source, query, v, requestCache) {
            // FIXME By flow we mean e.g. store.labels
            this.source = source;

            this.requestCache = requestCache || new service.RequestCache();
        },
        
        /**
         * Function for actually retrieving data from the underlying service and updating caches as needed.
         *
         * Don't call this method directly; it may corrupt caches!
         */
        fetchDocs: function(nodes) {
            var resultCache = this.requestCache.getResultCache();
            
            var executionCache = this.requestCache.getExecutionCache();

            var result = this.source.find().nodes(nodes).asList(true).pipe(function(docs) {
                
                var r = new util.HashMap();

                _(docs).each(function(doc) {
                    var id = doc.id;
                    resultCache.setItem('' + id, doc);
                    r.put(id, doc);
                });

                _(nodes).each(function(item) {
                    delete executionCache['' + item];
                });
                
                return r;
            });

            _(nodes).each(function(item) {
                executionCache['' + item] = result;
            });
            
            
            return result;
        },
        
        lookup: function(nodes) {
            var self = this;

            //console.log('cache status [BEFORE] ' + JSON.stringify(self.requestCache));

            // Make nodes unique
            var uniq = _(nodes).uniq(false, function(x) {
                // FIXME Meh, uniq only supports transformations but not a custom equals method
                //return util.defaultEquals(a, b);
                return '' + x;
            });

            var resultMap = new util.HashMap();

            var resultCache = this.requestCache.getResultCache();
            var executionCache = this.requestCache.getExecutionCache();
            
            // Check whether we need to wait for promises that are already executing
            var open = [];
            var waitForNodes = [];
            var waitForPromises = [];
            
            _(uniq).each(function(node) {
                var id = '' + node;

                var val = resultCache.getItem(id);
                if(!val) {
                    
                    var promise = executionCache[id];
                    if(promise) {
                        waitForNodes.push(node);

                        var found = _(waitForPromises).find(function(x) {
                            var r = x == promise;
                            return r;
                        });

                        if(!found) {
                            waitForPromises.push(promise);
                        }
                    }
                    else {
                        open.push(node);
                        waitForNodes.push(node);
                    }
                } else {
                    resultMap.put(node, val);
                }
            });
            
            
            if(open.length > 0) {
                var p = this.fetchDocs(open);
                waitForPromises.push(p);
            }
            
            var result = jQuery.when.apply(window, waitForPromises).pipe(function() {
                var maps = arguments;
                _(waitForNodes).each(function(node) {
                    
                    var val = null;
                    _(maps).find(function(map) {
                        val = map.get(node);
                        return !!val;
                    });
                    
                    if(val) {
                        resultMap.put(node, val);
                    }
                });
                
                return resultMap;
            });
            
            return result;
        }
    });
        
    
    myModule.controller('FaceteAppCtrl', ['$scope', '$q', '$rootScope', function($scope, $q, $rootScope) {

        
        // Quick test of the the .nodes() parameter
        if(false) {
            var sparqlService = new service.SparqlServiceHttp('http://dbpedia.org/sparql', ['http://dbpedia.org']);

            var nodes = [rdf.NodeFactory.createUri('http://dbpedia.org/resource/London'), rdf.NodeFactory.createUri('http://dbpedia.org/resource/Leipzig')];
            var store = new sponate.StoreFacade(sparqlService);
            
            var labelMap = sponate.SponateUtils.createDefaultLabelMap();
            store.addMap(labelMap, 'labels');
            var labelsStore = store.labels;    

            var labelService = new SponateLookupServiceImpl(labelsStore);
            for(var i = 0; i < 10; ++i) {
	            (function(i) {
		            labelService.lookup(nodes).done(function(result) {
		                console.log('lookup result [' + i + ']: ' + JSON.stringify(result.entries()));
		            });
	                labelService.lookup([nodes[0]]).done(function(result) {
	                    console.log('lookup result [' + i + ']: ' + JSON.stringify(result.entries()));
	                });
	                labelService.lookup([nodes[1]]).done(function(result) {
	                    console.log('lookup result [' + i + ']: ' + JSON.stringify(result.entries()));
	                });
	            })(i);
            }
            
            /*
            store.labels.find().nodes(nodes).asList().done(function(result) {
                alert(JSON.stringify(result));
            });
            */

        }   
            

        
        /**
         * Used for progress bar
         */
        $scope.Math = Math;


		$scope.active = {};

		

		/* Application UI state */
        $scope.app = {
   			search: {
   				show: false,
   				isOpen: false
   			},
   			dataSources: {
   				isOpen: false,
   				showAddDialog: false
   			},
   			data: {
   				isOpen: false,
   				tabs: [{isActive: true}, {isActive: false}, {isActive: false}, {isActive: false}, {isActive: false}],
   				originalBounds: {}, // Bounds to restore size
   				bounds: {} // Bounds for current size; watched and synced by the directive
   			},
   			geoLinks: {
   				isOpen: false
   			},
   			facets: {
   			    isOpen: false
   			}
        };

		
        var resizableConfigEnabled = {
		    handles: 'n, e, ne',
		    containment: 'parent',
		    
		    create: function(event, ui) {
		        jQuery(event.target).on('resize', function (e, ui) {
		            // Prevent the top attribute from getting set
		            jQuery(event.target).css('top', '');
		        });
		    },
		    
		    // Resize might not working properly, if there are parent elements with pointer-events: none involved
		    start: function(event, ui) {
		        var el = jQuery(event.target);
		                        
		        this.pointerEventsResets = el.parents().filter(function() {
		            var attrVal = jQuery(this).css('pointer-events');
		            var r = attrVal === 'none';
		            //console.log('resize', this, attrVal, r)
		            return r;
		        });
		        
		        this.pointerEventsResets.css('pointer-events', 'auto');
		    },
		    stop: function(event, ui) {
		        this.pointerEventsResets.css('pointer-events', 'none');
		    }
		};

        var resizableConfigDisabled = {handles: 'none', disabled: true};

        $scope.resizableConfig = resizableConfigDisabled;

        
        $scope.$watch('app.data.isOpen', function(state) {
            $scope.resizableConfig = state ? resizableConfigEnabled : resizableConfigDisabled;
        });
            
        

		
		
        $scope.edit = {
	        id: null,
	        dataServiceIri: '',
	        dataGraphIris: '',
	        jsServiceIri: '',
	        jsGraphIris: ''
		};
            
        
        var storeApiUrl = 'api/store';

        
        
        var facetTableConfig; // Initialized later - TODO Fix the order
        
        var createDefaultWorkspaceConfig = function() {
	        var result = {
		        name: 'Unnamed Data Source',
		        dataService: {
		            serviceIri: '',
		            defaultGraphIris: []
		        },
		        joinSummaryService: {
		            serviceIri: '',
		            defaultGraphIris: []
		        },
		        conceptPathFinderApiUrl: 'api/path-finding',        
		        facetTreeConfig: facetTreeConfig,
		        mapConfig: {
		            mapFactory: geo.GeoMapFactoryUtils.wgs84MapFactory,
		            geoConcept: geo.GeoConcepts.conceptWgs84,
					quadTreeConfig: {
						maxItemsPerTileCount: 1000,
						maxGlobalItemCount: 2000
		        	}
		      	},
	            facetTableConfig: facetTableConfig
		    };
	        
	        return result;
        };
        
        
        var applyScope = function() {
			if(!$scope.$$phase) {
                $scope.$apply();
            }			
        };
        
        refreshDataSources = function() {
			var spec = {
				url: storeApiUrl + '/loadState',
				traditional: true,
				data: {
					type: 'dataSource'
				},
				dataType: 'json'
			};
            
            jQuery.ajax(spec).done(function(response) {
                
                var configs = _(response).map(function(record) {
                    var item = record.data;
                    item.id = record.id;
                    
                    var spec = createDefaultWorkspaceConfig();
                    console.log('ITEM', item);
                    spec.id = item.id;
                    spec.name = item.name;
                    spec.dataService.serviceIri = item.dataServiceIri;
                    spec.dataService.defaultGraphIris = item.dataGraphIris;
                    spec.joinSummaryService.serviceIri = item.jsServiceIri;
                    spec.joinSummaryService. defaultGraphIris = item.jsGraphIris;
                    
                    return spec;
                });
                console.log('CONFIGS', configs);
                
                $scope.active.serviceConfigs = configs;
                
                applyScope();
                //alert('yay' + JSON.stringify(response));
            }).fail(function() {
                alert('Failed to retrieve data sources');
            });
        };
        
        
        $scope.deleteDataSource = function(id) {
            
            var c = confirm('Delete dataset with id ' + id + '?');
            if(!c) {
                return;
            }

			var spec = {
					url: storeApiUrl + '/deleteState',
					type: 'POST',
					traditional: true,
					data: {
					    type: 'dataSource',
					    id: id
					},
					dataType: 'json'
			};

            jQuery.ajax(spec).done(function(response) {
				// FIXME Verify the response for success
            }).fail(function() {
				alert('Failed to delete data source with id ' + id);
		        //$scope.active.service = serviceConfigs.length === 0 ? null : serviceConfigs[0];

            }).then(function() {
            	refreshDataSources();                
            });

        }
        
        $scope.addDataSource = function() {
            var raw = _($scope.edit).clone();
            
            
            raw.dataGraphIris = raw.dataGraphIris.match(/\S+/g);
            raw.jsGraphIris = raw.jsGraphIris.match(/\S+/g);
            
            var data = JSON.stringify(raw);
            
			var spec = {
				url: storeApiUrl + '/saveState',
				type: 'POST',
				traditional: true,
				data: {
				    type: 'dataSource',
				    data: data
				},
				dataType: 'json'
			};
            
            jQuery.ajax(spec).done(function(response) {
                // Hide data source creation dialog
                //$scope.app.dataSources.isOpen = false;
                $scope.app.dataSources.showAddDialog=false

            	refreshDataSources();
    			//alert('yay' + JSON.stringify(response));
            }).fail(function() {
				alert('Failed to store data');
            });
            
        };

		
		
		var vs = rdf.NodeFactory.createVar('s');


		/* Dummy init */
        var dummyQuery = new sparql.Query();
        dummyQuery.getProject().add(vs);
        dummyQuery.getElements().push(new sparql.ElementTriplesBlock([new rdf.Triple(vs, vs, vs)]));
        
        var tmpTableMod = new facete.TableMod();
        tmpTableMod.addColumn('s');
        $scope.active.facetTableConfig = {
            queryFactory: new facete.QueryFactoryConst(dummyQuery),
            tableMod: tmpTableMod
        };


		var facetTreeConfig = new facete.FacetTreeConfig();
        var targetFacetTreeConfig = new facete.FacetTreeConfig();

		
		// On startup, expand the root facet node
		var rootPath = new facete.Path()
		facetTreeConfig.getExpansionSet().add(rootPath);
		facetTreeConfig.getExpansionMap().put(rootPath, 1);

        targetFacetTreeConfig.getExpansionSet().add(rootPath);
        targetFacetTreeConfig.getExpansionMap().put(rootPath, 1);

		
		var facetConfig = facetTreeConfig.getFacetConfig();
		var pathTaggerManager = facetConfig.getPathTaggerManager()
		var taggerMap = pathTaggerManager.getTaggerMap();
		
		
        facetTableConfig = new facete.FacetTableConfig(facetConfig);
		var tableMod = facetTableConfig.getTableMod();
		tableMod.addColumn('s'); // TODO Instead of 's' use: facetConfig.getBaseConcept().getVar().getName()
		
		taggerMap.table = new facete.ItemTaggerMembership(facetTableConfig.getPaths());

		
		
		var geoConceptFactory = new facete.ConceptFactoryFacetTreeConfig(facetTreeConfig);


		var conceptFalse = new facete.Concept(sparql.ElementString.create('?s a <http://foo.bar>'), vs);

		var filterConceptFactory = new facete.ConceptFactoryConst(conceptFalse)
		

		
		var visibleControls = new util.HashSet();
        taggerMap.controls = new facete.ItemTaggerMembership(visibleControls);
		
		$scope.facetTreePluginContext = {
		    toggleControls: function(path) {
		        if(path) {
		            util.CollectionUtils.toggleItem(visibleControls, path);
		        }
		    },

			toggleTableLink: function(path) {
			    //var active = $scope.active;
			    var active = $scope;
               	if(active.facetTableConfig) {
               	    active.facetTableConfig.togglePath(path);
               	}
               	
//                	if(active.allFacetTableConfig) {
//                	    active.allFacetTableConfig.togglePath(path);
//                	}
			}
		};


		$scope.facetTreePlugins = [
		    '<a style="margin-left: 5px; margin-right: 5px;" ng-show="data.isExpanded && (data.isHovered || data.item.getTags().controls.isContained)" href="" ng-click="context.toggleControls(data.item.getPath())"><span class="glyphicon glyphicon-cog"></span></a>',
            '<a style="margin-left: 5px; margin-right: 5px;" ng-show="data.isHovered || data.item.getTags().table.isContained" href="" ng-click="context.toggleTableLink(data.item.getPath())"><span class="glyphicon glyphicon-list-alt"></span></a>'
        ];

		
		
//         var tableMod = new facete.TableMod();
//         //tableMod.addColumn('s');
//         tableMod.addColumn('_p_');
//         tableMod.addColumn('_o_');

		
		$scope.active.sparqlService = new service.SparqlServiceDummy();
		$scope.active.geoConceptFactory = geoConceptFactory;

		
		
		refreshDataSources();
		
        $scope.active.serviceConfigs = [];
            
        var deleteThisWhenDbIsDone =
        [
			{        
		        name: 'FP7 ICT Project Partners (local)',
		        dataService: {
		            serviceIri: 'http://localhost/data/fp7-pp/sparql',
		            defaultGraphIris: ['http://fp7-pp.publicdata.eu/']
		        },
		        joinSummaryService: {
		            serviceIri: null,
		            defaultGraphIris: []
		        },
		        conceptPathFinderApiUrl: 'api/path-finding',        
		        facetTreeConfig: facetTreeConfig,
		        mapConfig: {
		            mapFactory: geo.GeoMapFactoryUtils.wgs84MapFactory,
		            geoConcept: geo.GeoConcepts.conceptWgs84,
					quadTreeConfig: {
						maxItemsPerTileCount: 1000,
						maxGlobalItemCount: 2000
					}
				}
			},
			{
            name: 'Freebase Germany (local)',
            dataService: {
                serviceIri: 'http://localhost/data/freebase/germany/sparql',
                defaultGraphIris: ['http://freebase.com/2013-09-22/data/']
            },
            joinSummaryService: {
                serviceIri: null,
                defaultGraphIris: []
            },
            conceptPathFinderApiUrl: 'api/path-finding',
            facetTreeConfig: facetTreeConfig,
            mapConfig: {
                mapFactory: geo.GeoMapFactoryUtils.wgs84MapFactory,
                geoConcept: geo.GeoConcepts.conceptWgs84,
			    quadTreeConfig: {
					maxItemsPerTileCount: 1000,
					maxGlobalItemCount: 2000
				}
            }
        },
        {
            name: 'GeoStats (local)',
            dataService: {
                serviceIri: 'http://localhost/data/geostats/sparql',
                defaultGraphIris: ['http://localhost/geostats.nt']
            },
            joinSummaryService: {
                serviceIri: null,
                defaultGraphIris: []
            },
            conceptPathFinderApiUrl: 'api/path-finding',
            facetTreeConfig: facetTreeConfig,
            mapConfig: {
                mapFactory: geo.GeoMapFactoryUtils.ogcVirtMapFactory,
                geoConcept: geo.GeoConcepts.conceptGeoVocab,
			    quadTreeConfig: {
					maxItemsPerTileCount: 1000,
					maxGlobalItemCount: 2000
				}
            }
        },
        {        
            name: 'DBpedia, geo & types (local)',
            dataService: {
                serviceIri: 'http://localhost/data/dbpedia/3.9/sparql',
                defaultGraphIris: ['http://dbpedia.org/3.9/']
            },
            joinSummaryService: {
                serviceIri: null,
                defaultGraphIris: []
            },
            conceptPathFinderApiUrl: 'api/path-finding',        
            facetTreeConfig: facetTreeConfig,
            mapConfig: {
                mapFactory: geo.GeoMapFactoryUtils.wgs84MapFactory,
                geoConcept: geo.GeoConcepts.conceptWgs84,
			    quadTreeConfig: {
					maxItemsPerTileCount: 1000,
					maxGlobalItemCount: 2000
				}
            }
        },
        {
            name: 'GeoKnow Y1 Demo Dataset (local)',
            dataService: {
                serviceIri: 'http://localhost/data/geoknow/demo/y1/sparql',
                defaultGraphIris: []
            },
            joinSummaryService: {
                serviceIri: null,
                defaultGraphIris: []
            },
            conceptPathFinderApiUrl: 'api/path-finding',
            facetTreeConfig: facetTreeConfig,
            mapConfig: {
                mapFactory: geo.GeoMapFactoryUtils.wgs84MapFactory,
                geoConcept: geo.GeoConcepts.conceptWgs84,
			    quadTreeConfig: {
					maxItemsPerTileCount: 1000,
					maxGlobalItemCount: 2000
				}
            }
        },
        {        
            name: 'FP7 ICT Project Partners (remote)',
            dataService: {
                serviceIri: 'http://fp7-pp.publicdata.eu/sparql',
                defaultGraphIris: ['http://fp7-pp.publicdata.eu/']
            },
            joinSummaryService: {
                serviceIri: null,
                defaultGraphIris: []
            },
            conceptPathFinderApiUrl: 'api/path-finding',        
            facetTreeConfig: facetTreeConfig,
            mapConfig: {
                mapFactory: geo.GeoMapFactoryUtils.wgs84MapFactory,
                geoConcept: geo.GeoConcepts.conceptWgs84,
			    quadTreeConfig: {
					maxItemsPerTileCount: 1000,
					maxGlobalItemCount: 2000
				}
            }
        },
//         {
//             name: 'GeoKnow Demo Dataset (remote)',
//             dataService: {
//                 serviceIri: 'http://cstadler.aksw.org/geoknow/sparql',
//                 defaultGraphIris: []
//             },
//             joinSummaryService: {
//                 serviceIri: null,
//                 defaultGraphIris: []
//             },
//             conceptPathFinderApiUrl: 'api/path-finding',
//             facetTreeConfig: facetTreeConfig,
//             mapConfig: {
//                 mapFactory: geo.GeoMapFactoryUtils.wgs84MapFactory,
//                 geoConcept: geo.GeoConcepts.conceptWgs84,
// 			    quadTreeConfig: {
// 					maxItemsPerTileCount: 1000,
// 					maxGlobalItemCount: 2000
// 				}
//             }
//         },
        {        
            name: 'DBpedia, official (remote)',
            dataService: {
                serviceIri: 'http://dbpedia.org/sparql',
                defaultGraphIris: ['http://dbpedia.org']
            },
            joinSummaryService: {
                serviceIri: 'http://cstadler.aksw.org/service/join-summary/sparql',
                defaultGraphIris: ['http://dbpedia.org/2013-12-22/join-summary-essential/']
            },
            conceptPathFinderApiUrl: 'api/path-finding',        
            facetTreeConfig: facetTreeConfig,
            mapConfig: {
                mapFactory: geo.GeoMapFactoryUtils.wgs84MapFactory,
                geoConcept: geo.GeoConcepts.conceptWgs84,
			    quadTreeConfig: {
					maxItemsPerTileCount: 1000,
					maxGlobalItemCount: 2000
				}
            }
        },
        {
            name: 'LinkedGeoData (remote)',
            dataService: {
                serviceIri: 'http://linkedgeodata.org/sparql',
                defaultGraphIris: ['http://linkedgeodata.org']
            },
            joinSummaryService: {
                serviceIri: 'http://linkedgeodata.org/join-summary/sparql',
                defaultGraphIris: ['http://linkedgeodata.org/join-summary']
            },
            conceptPathFinderApiUrl: 'api/path-finding',
            facetTreeConfig: facetTreeConfig,
            mapConfig: {
                mapFactory: geo.GeoMapFactoryUtils.wgs84MapFactory,
                geoConcept: geo.GeoConcepts.conceptWgs84,
			    quadTreeConfig: {
					maxItemsPerTileCount: 1000,
					maxGlobalItemCount: 2000
				}
            }
        }
//         {
//             name: 'GeoStats (remote)',
//             dataService: {
//                 serviceIri: 'http://cstadler.aksw.org/service/geostats/sparql',
//                 defaultGraphIris: ['http://geostats.aksw.org/']
//             },
//             joinSummaryService: {
//                 serviceIri: null,
//                 defaultGraphIris: []
//             },
//             conceptPathFinderApiUrl: 'api/path-finding',
//             facetTreeConfig: facetTreeConfig,
//             mapConfig: {
//                 mapFactory: geo.GeoMapFactoryUtils.ogcVirtMapFactory,
//                 geoConcept: geo.GeoConcepts.conceptGeoVocab,
// 			    quadTreeConfig: {
// 					maxItemsPerTileCount: 1000,
// 					maxGlobalItemCount: 2000
// 				}
//             }
//         },
//         {
//             name: 'LGD Sparqlify Localhost',
//             dataService: {
//                 serviceIri: 'http://localhost:7531/sparql',
//                 defaultGraphIris: []
//             },
//             joinSummaryService: {
//                 serviceIri: 'http://linkedgeodata.org/join-summary/sparql',
//                 defaultGraphIris: ['http://linkedgeodata.org/join-summary']
//             },
//             conceptPathFinderApiUrl: 'api/path-finding',
//             facetTreeConfig: facetTreeConfig,
//             mapConfig: {
//                 mapFactory: geo.GeoMapFactoryUtils.wgs84MapFactory,
//                 geoConcept: geo.GeoConcepts.conceptWgs84,
// 			    quadTreeConfig: {
// 					maxItemsPerTileCount: 1000,
// 					maxGlobalItemCount: 2000
// 				}
//             }
        ];

        
        /**
         * Init of derived attributes
         *
         */
         
//        _($scope.active.serviceConfigs).each(function(serviceConfig) {
            // Create the facetTableConfig
// 			var facetTreeConfig = serviceConfig.facetTreeConfig;
//             var facetConfig = facetTreeConfig.getFacetConfig()


//            serviceConfig.facetTableConfig = facetTableConfig;

            // Init the taggerMap
//     		var pathTaggerManager = facetConfig.getPathTaggerManager()
//     		var taggerMap = pathTaggerManager.getTaggerMap();
    		
//     		taggerMap.table = new facete.ItemTaggerMembership(facetTableConfig.getPaths());
    		
    		// Init the tableMod
//     		var tableMod = facetTableConfig.getTableMod();
//     		tableMod.addColumn('s');
//        });

        
        // On startup, show the list of types
        $scope.active.path = facete.Path.parse(vocab.rdf.type.getUri());
        $scope.active.targetPath = facete.Path.parse(vocab.rdf.type.getUri());


        $scope.findConceptPaths = function(sourceConcept, targetConcept) {
            var conceptPathFinder = $scope.active.conceptPathFinder;

            var promise = conceptPathFinder.findPaths(sourceConcept, targetConcept);
            var result = sponate.angular.bridgePromise(promise, $q.defer(), $rootScope, function(paths) {
                var tmp = _(paths).map(function(path) {

                    var pathName = path.toString();
                    if(pathName === '') {
                        pathName = '(empty path)';
                    }

                    var r = {
                        name: pathName,
                        path: path
                    };
                    return r;
                });
                
                return tmp;
            });
            
            return result;
        };
		
		/*
		 * Concept Path Finding
		 */
		var refresh = function(config) {
			
		    var conceptPathFinderApiUrl = config.conceptPathFinderApiUrl;
		    var sparqlServiceIri = config.dataService.serviceIri;
		    var defaultGraphIris = config.dataService.defaultGraphIris;
		    var joinSummaryServiceIri = config.joinSummaryService.serviceIri;
		    var joinSummaryDefaultGraphIris = config.joinSummaryService.defaultGraphIris;
		    
		    
		    var geoConcept = config.mapConfig.geoConcept;
		    
		    var conceptPathFinder = new client.ConceptPathFinderApi(conceptPathFinderApiUrl, sparqlServiceIri, defaultGraphIris, joinSummaryServiceIri, joinSummaryDefaultGraphIris);
            $scope.active.conceptPathFinder = conceptPathFinder;
		    
            var facetTreeConfig = config.facetTreeConfig;
    		var conceptFactory = new facete.ConceptFactoryFacetTreeConfig(facetTreeConfig);

		    
		    var sourceConcept = conceptFactory.createConcept(); 	
			var targetConcept = geoConcept;
								
			
// 			var cpfSparqlService = conceptPathFinder.createSparqlService(sourceConcept, targetConcept);
// 			var qe = cpfSparqlService.createQueryExecution('Select * { ?s ?p ?o } Limit 10');
// 			qe.execSelect().done(function(rs) {
// 				alert(JSON.stringify(rs.getBindings()));
// 			}).fail(function() {
// 			    alert('fail');
// 			});
			
			$scope.findConceptPaths(sourceConcept, targetConcept).then(function(tmp) {
			    $scope.active.geoPaths = tmp;
			});
			             
			
            /*
		    var promise = conceptPathFinder.findPaths(sourceConcept, targetConcept);
			var result = sponate.angular.bridgePromise(promise, $q.defer(), $rootScope, function(paths) {
			    var tmp = _(paths).map(function(path) {

			        var pathName = path.toString();
			        if(pathName === '') {
			            pathName = '(empty path)';
			        }

			        var r = {
						name: pathName,
						path: path
					};
			        return r;
			    });
			   
			    $scope.active.geoPaths = tmp;
			});
			/*
			, function(err) {
			    alert(err.responseText);
			});
    */
		};
		        
		var hashToService = {};
		
       	var refreshServices = function(config) {
       	    if(!config) {
				return;
       	    }

            var dataCnf = config.dataService;

            var facetTreeConfig = config.facetTreeConfig;
            
            var serviceState = {
                url: 'cache/sparql',
                defaultGraphIris: dataCnf.defaultGraphIris,
                ajaxOptions: {},
                httpOptions: {
                    'service-uri': dataCnf.serviceIri
                }
            };
            
            var serviceHash = util.ObjectUtils.hashCode(serviceState);
            var sparqlService = hashToService[serviceHash];
                        
            if(!sparqlService) {
                //alert('Service: ' + serviceHash);

	    		sparqlService = new service.SparqlServiceHttp('cache/sparql', dataCnf.defaultGraphIris, {}, {'service-uri': dataCnf.serviceIri});
	            //var sparqlService = new service.SparqlServiceHttp(dataCnf.serviceIri, dataCnf.defaultGraphIris);
	    		
	    		sparqlService = new service.SparqlServiceCache(sparqlService);
	            sparqlService = new service.SparqlServiceVirtFix(sparqlService);
	    		sparqlService = new service.SparqlServicePaginate(sparqlService, 1000);
	    		
	    		hashToService[serviceHash] = sparqlService;
            }
            else {
                console.log('Service reused: ', serviceHash);
            }
            
            
    		$scope.active.sparqlService = sparqlService;		
            $scope.active.facetTreeConfig = facetTreeConfig;
            $scope.active.targetFacetTreeConfig = targetFacetTreeConfig;

            
            refreshEssentialTables();
            
    		/*
    		 * <- Facet Tree 'Link-Facet-To-Table' Plugin
    		 */
            var conceptFactory = new facete.ConceptFactoryFacetTreeConfig(facetTreeConfig);

    		var facetConfig = facetTreeConfig.getFacetConfig()

    		var facetTreeConfig = $scope.active.facetTreeConfig;
    	    var facetConceptFactory = new facete.ConceptFactoryFacetTreeConfig(facetTreeConfig);        
    	    var facetElementFactory = new facete.ElementFactoryConceptFactory(facetConceptFactory);        
    		
    		
            var facetTableConfig = config.facetTableConfig;
    		var tableMod = facetTableConfig.getTableMod();

    		
    		var ConceptFactoryFtc = Class.create(facete.ConceptFactory, {
                initialize: function(facetTableConfig) {
                    this.facetTableConfig = facetTableConfig;
                },
                
                createConcept: function() {
                    var result = this.facetTableConfig.createDataConcept();
                    return result;
                }
    		});

    		// TODO The data concept is dynamic
            //var dataConcept = facetTableConfig.createDataConcept();
    		var dataConceptFactory = new ConceptFactoryFtc(facetTableConfig);
    		
            //var dataElementFactory = new sparql.ElementFactoryConst(dataConcept.getElement());
            var dataElementFactory = new facete.ElementFactoryConceptFactory(dataConceptFactory);
            
            var filterElementFactory = new facete.ElementFactoryConceptFactory(filterConceptFactory);

            // NOTE We assume the data and filter concept share the same variables
            var elementFactory = new sparql.ElementFactoryCombine(true, [dataElementFactory, filterElementFactory]);
            var queryFactory = new facete.QueryFactoryTableMod(elementFactory, tableMod);

    		$scope.active.facetTableConfig = {
    			queryFactory: queryFactory,
    			tableMod: tableMod
    		};
    		

            //var allQueryFactory = new facete.QueryFactoryTableMod(dataElementFactory, tableMod);
            var allElementFactory = new sparql.ElementFactoryCombine(true, [dataElementFactory, facetElementFactory]);
            var allQueryFactory = new facete.QueryFactoryTableMod(allElementFactory, tableMod);

    		$scope.active.allFacetTableConfig = {
    		    queryFactory: allQueryFactory,
    		    tableMod: tableMod
    		};
    		
    		
    		// HACK! because of name clash in .active
    		// For some reason, this lines makes the toggle column button in the facet tree work - but WHY??????
    		$scope.facetTableConfig = facetTableConfig;
    		//$scope.allFacetTableConfig = $scope.active.allFacetTableConfig;
    		/*
    		 * ->
    		 */
            

            
            
            
    		var mapConfig = config.mapConfig;
            var mapFactory = config.mapFactory;
    		
            $scope.active.dataSources = [{
    			sparqlService: sparqlService,
    			mapFactory: mapConfig.mapFactory,
    			conceptFactory: geoConceptFactory,
    		    quadTreeConfig: mapConfig.quadTreeConfig
    		}];

        };

        $scope.active.dataSources = [];
        
        
        $scope.setDataSource = function(item) {
            alert(JSON.stringify(item));
        };
        
//         $scope.$watch('dataSourceSelection.active', function(val) {
// 			alert(JSON.stringify(val));
//         });

		$scope.ObjectUtils = util.ObjectUtils;
		
		
		//$scope.$watch('ObjectUtils.hashCode(facetTreeConfig)', function() {
		//$scope.$watch('ObjectUtils.hashCode(active.service)', function() {

		// Important: We should only refresh the services if the *reference* to
		// the config object changes - it doesn't make sense to refresh if an internal config
		// parameter changes, as we would keep refreshing
		$scope.$watch('active.service', function() {
		    var config = $scope.active.service;
		    if(config) {
		    	refreshServices(config);
		    	refresh(config);
		    }
		});
		
		
		
		$scope.$watch('ObjectUtils.hashCode(active.targetFacetTreeConfig)', function() {
            var sourceConceptFactory = new facete.ConceptFactoryFacetTreeConfig(facetTreeConfig);
            var sourceConcept = sourceConceptFactory.createConcept();     

            var targetConceptFactory = new facete.ConceptFactoryFacetTreeConfig(targetFacetTreeConfig);
            var targetConcept = targetConceptFactory.createConcept();     
            
		    $scope.findConceptPaths(sourceConcept, targetConcept).then(function(tmp) {
                $scope.active.targetGeoPaths = tmp;
            });
		    
		});
		
		//active.allFacetTableConfig
		//active.sparqlService
		//$scope.$watch('ObjectUtils.hashCode(active.allFacetTableConfig)', function(n, o) {
// 		$scope.$watch('active.allFacetTableConfig', function(n, o) {
// 		    //console.log('Service changed [old]', o);
// 		    console.log('Service changed [now]', n);
// 		    debugger;
// 		});
		
		$scope.$watch('ObjectUtils.hashCode(active.facetTreeConfig)', function() {
            var config = $scope.active.service;
            if(config) {
                refresh(config);
            }
		}, true);

		
		
		
		var serviceConfigs = $scope.active.serviceConfigs
        $scope.active.service = serviceConfigs.length === 0 ? null : serviceConfigs[0];


		
		$scope.setGeoPath = function(path) {
		    $scope.active.geoConceptFactory.setPath(path);
		};

        $scope.selectFacet = function(path) {
            $scope.active.path = path;
        };

        $scope.selectTargetFacet = function(path) {
            $scope.active.targetPath = path;
        };

        $scope.selectGeom = function(data) {
            console.log('Data selected: ', data);
        
            var geoConceptFactory = data.config.conceptFactory;
            
            var geoConcept = geoConceptFactory.createConcept();
            var vs = geoConcept.getVar();
            var rootVar = geoConceptFactory.getFacetTreeConfig().getFacetConfig().getBaseConcept().getVar();
            
            
           	//alert('Select: ' + JSON.stringify(data));
			var node = data.id;
            var ev = new sparql.ExprVar(vs);
            var nodeValue = sparql.NodeValue.makeNode(node);
            var expr = new sparql.E_Equals(ev, nodeValue);
            var elementFilter = new sparql.ElementFilter(expr);
            
            var elements = geoConcept.getElements().slice(0);
            elements.push(elementFilter);
            
            
			var concept = facete.Concept.createFromElements(elements, rootVar);

			//alert('SelectConcept: ' + concept);
			
			filterConceptFactory.setConcept(concept);

			if(!$scope.$$phase) {
                $scope.$apply();
            }
        }

        $scope.unselectGeom = function(data) {
            //alert('Unselect: ' + JSON.stringify(data));
			filterConceptFactory.setConcept(conceptFalse);
			if(!$scope.$$phase) {
                $scope.$apply();
            }
        }


        
        $scope.nextConceptSpaceId = 1;
        $scope.conceptSpaces = [];
        
        
        $scope.addConceptSpace = function() {
            var conceptSpaceId = '' + ($scope.nextConceptSpaceId++);
            
            var conceptSpaceName = 'concept-' + conceptSpaceId;
            
            if(conceptSpaceId === '1') {
				conceptSpaceName = 'Hotels @ DBpedia';
            }

            if(conceptSpaceId === '2') {
				conceptSpaceName = 'Hotels @ Wikimapia';
            }

            if(conceptSpaceId === '3') {
				conceptSpaceName = 'Airports @ Freebase';
            }

			var config = {
			    id: conceptSpaceId,
			    name: conceptSpaceName
			};
			
			$scope.conceptSpaces.push(config);
        };
        
        $scope.selectConceptSpace = function(index) {
			_($scope.conceptSpaces).each(function(conceptSpace) {
				conceptSpace.active = false;
			});
			
			$scope.conceptSpaces[index].active = true;
        };
        
        $scope.removeConceptSpace = function(index) {
			$scope.conceptSpaces.splice(index, 1);
        };
        
        
        $scope.searchResults = [];
        
        $scope.doSearch = function(searchString) {
            $scope.app.search.show = true;
            $scope.app.search.isOpen = true;
            
            var ajaxSpec = {
				crossDomain: true,
				url: 'http://nominatim.openstreetmap.org/search/',
				dataType: 'json',
				traditional: 'true',
				data: {
				    format: 'json',
					q: searchString
				}
            };
            
            var promise = jQuery.ajax(ajaxSpec).pipe(function(items) {
                _(items).each(function(item) {
                    var nameParts = item.display_name.split(',');
                    
                    item.primaryName = nameParts[0];
                    item.description = nameParts[1];
                });

                return items;
            });
            
			sponate.angular.bridgePromise(promise, $q.defer(), $rootScope, function(data) {
			    $scope.searchResults = data;
			});
        };
        
        $scope.active.mapConfig = {};
        
        $scope.selectSearchResult = function(item) {
			$scope.active.mapConfig.center = {lon: item.lon, lat: item.lat},
			$scope.active.mapConfig.zoom = 13;
        };

        
        $scope.notifications = [];
        
        
        
        var applyRootScope = function(scope) {
            var rootScope = scope.$root;

            if(!rootScope.$$phase) {
                rootScope.$apply()
            }
        };
        
        
        
        var metaPrefixes = {
			'rdfs': 'http://www.w3.org/2000/01/rdf-schema#',
            'batch': 'http://ns.aksw.org/spring/batch/'
        };
    	var metaSparqlService = new service.SparqlServiceHttp('api/export-status/sparql', []);	
    	var metaStore = new sponate.StoreFacade(metaSparqlService, metaPrefixes);
    	
   		metaStore.addMap({
   			name: 'sparqlExports',
   			template: [{
   				id: '?je',
   				context: '?jec',
   				exitCode: '?jeec',
   				status: '?jes',
   				steps: [{
   					id: '?se',
   					label: '?sel',
   					context: '?sec'
   				}]
   			}],
   			from:
'{ Select ?je ?jeec ?jes ?jec ?se ?sel ?sec {\
  ?je\
    a batch:JobExecution ;\
    batch:exitCode ?jeec ;\
    batch:status ?jes ;\
    batch:shortContext ?jec ;\
    batch:stepExecution ?se .\
\
  ?se\
    rdfs:label ?sel ;\
    batch:shortContext ?sec .\
} }'
   		});
       
   		
   		/**
   		 * Index the map of a spring batch object
   		 */
   		var indexBatchMap = function(map) {
   		    var result;
   		    var entry = map ? map.entry : null;
   		    
   		    if(!entry) {
   		        result = {};
   		    }
   		    else if(_(entry).isArray()) {
				result = _(entry).indexBy('string');
			}
   		    else {
				result = {};
				var key = entry['string'];
				result[key] = entry;
   		    }
   		    
   		    return result;
   		}
        
   		
   		var processJobStatus = function(item) {
		    var jobContext = JSON.parse(item.context);

			var jobMap = indexBatchMap(jobContext.map);
			console.log(jobMap); 

			var tmp = jobMap['DataCountTasklet.count'];
			var countStr = tmp ? tmp['long'] : null; 
			    
			    
			var maxItemCount = countStr != null ? parseInt(countStr) : null;
			var itemCount = 0;
		    
		    _(item.steps).each(function(step) {
				if(step.label === 'dataFetchStep') {
				    var stepContext = JSON.parse(step.context);
				    var stepMap = indexBatchMap(stepContext.map);
				    
					itemCount = parseInt(stepMap['FlatFileItemWriter.written']['long']);
				}
		    });
		    
		    var isRunning = item.status !== 'STOPPED' && item.status !== 'COMPLETED' && item.status !== 'FAILED'; 
		    
		    var result = {
		        id: item.id.slice(1, -1),
		        isRunning: isRunning,
		        isCounting: isRunning && maxItemCount == null,
		        isRetrieving: isRunning && maxItemCount != null,
		        isFinished: !isRunning,
		        isFailed: !isRunning && item.exitCode !== 'COMPLETED',
		        isSucceeded: !isRunning && item.exitCode === 'COMPLETED',
		        progress: {
		            current: itemCount,
					max: maxItemCount,
					percentage: (maxItemCount != null) ? Math.floor(itemCount / maxItemCount * 100) : 0
		        }
		    };
		    
		    //alert(JSON.stringify(result));
			
		    
		    return result;
   		};


        var watchExport = function(jobExecutionUri, status) {
            var v = rdf.NodeFactory.createVar('je');
            var elementFilter = new sparql.ElementFilter(new sparql.E_Equals(new sparql.ExprVar(v), sparql.NodeValue.makeNode(rdf.NodeFactory.createUri(jobExecutionUri))));
            
            var element = new sparql.ElementGroup([
				new sparql.ElementTriplesBlock([
					new rdf.Triple(v, rdf.NodeFactory.createVar('ppp'), rdf.NodeFactory.createVar('ooo'))
				]),
				elementFilter
			]);
            
            var concept = new facete.Concept(element, v);
	
			var promise = metaStore.sparqlExports.find().concept(concept).asList();
			promise.done(function(data) {
			    
			    var item = data[0];
				
			    //alert('yay' + JSON.stringify(item));
			    
			    var jobStatus = processJobStatus(item);
			    
		        status.jobStatus = jobStatus;		        
                applyRootScope($scope);

				console.log('Still alive: ', jobStatus.isRunning);

			    if(jobStatus.isRunning) {
				    setTimeout(function() {				        
				        watchExport(jobExecutionUri, status);
				    }, 3000);
			    }

			}).fail(function() {
			    alert('fail');
			});
        };
        
        $scope.exportAll = function() {
            var queryFactory = $scope.active.allFacetTableConfig.queryFactory;
            var query = queryFactory.createQuery();
            //alert('' + query);

            var status = {
				msg: 'Export started.'
            };
            
            $scope.notifications.push(status);
                //applyRootScope($scope);

            
            var config = $scope.active.service;
            
            var promise = jQuery.ajax({
            	url: 'api/export/start',
            	traditional: true,
            	data: {
            	    'service-uri': config.dataService.serviceIri,
            		'default-graph-uri': config.dataService.defaultGraphIris,
            	    query: '' + query
            	}
            });
            
            promise.done(function(data) {
                //$scope.notifications.push({msg: 'Export successfully started: ' + data.id});
                status.msg = 'Export successfully started: ' + data.id;
               	applyRootScope($scope);
                
                watchExport(data.id, status);
                
            }).fail(function() {
                status.msg = 'Export failed: '; // + data.id;
               	applyRootScope($scope);
            });
        };
        
        
        var refreshEssentialTables = function() {

            /*
            \
            { Select Distinct ?instanceUri {\
              ?instanceUri a ?typeUri\
            } }\
            Prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> \
                Prefix geo: <http://www.w3.org/2003/01/geo/wgs84_pos#>\
                Select ?instanceLabel ?typeLabel ?instancePage ?typePage ?instanceUri ?typeUri ?lon ?lat {\
                    # Only get the most specific types (i.e. those that are not subclass of another)\
            */
// Filter(langMatches(lang(?instanceLabel), "de"))
// Filter(langMatches(lang(?typeLabel), "de"))

var dataElementStr =
'\
  Optional {\
    ?instanceUri a ?typeUri .\
    Optional {\
      ?typeUri2 <http://www.w3.org/2000/01/rdf-schema#subClassOf> ?typeUri\
    }\
    Filter(!Bound(?typeUri2))\
  }\
  Optional { ?instanceUri <http://www.w3.org/2000/01/rdf-schema#label> ?instanceLabel . Filter(langMatches(lang(?instanceLabel), "de"))}\
  Optional { ?instanceUri <http://www.w3.org/2003/01/geo/wgs84_pos#long> ?lon }\
  Optional { ?instanceUri <http://www.w3.org/2003/01/geo/wgs84_pos#lat> ?lat }\
  Optional { ?instanceUri <http://www.w3.org/2000/01/rdf-schema#seeAlso> ?instancePage }\
  Optional { ?typeUri <http://www.w3.org/2000/01/rdf-schema#label> ?typeLabel .Filter(langMatches(lang(?typeLabel), "en")) }\
  Optional { ?typeUri <http://www.w3.org/2000/01/rdf-schema#seeAlso> ?typePage }\
';

        var dataElement = sparql.ElementString.create(dataElementStr);
        
        var dataConcept = new facete.Concept(dataElement, rdf.NodeFactory.createVar('instanceUri'));
        
        var tableMod = new facete.TableMod();
        //var vs = essentialElement.getVarsMentioned();
        //var varNames = sparql.VarUtils.getVarNames(vs);
        var varNames = ['instanceLabel', 'typeLabel', 'instancePage', 'typePage', 'instanceUri', 'typeUri', 'lon', 'lat'];
        _(varNames).each(function(varName) {
            tableMod.addColumn(varName);
        });
        
        var varMap = new util.HashMap();
        var vs = rdf.NodeFactory.createVar('s');
        var viu = rdf.NodeFactory.createVar('instanceUri');
        varMap.put(vs, viu);
        
        var facetTreeConfig = $scope.active.facetTreeConfig;
        var baseFacetConceptFactory = new facete.ConceptFactoryFacetTreeConfig(facetTreeConfig);
        var facetConceptFactory = new facete.ConceptFactoryRename(baseFacetConceptFactory, varMap);
        
        var facetElementFactory = new facete.ElementFactoryConceptFactory(facetConceptFactory);        
        
 
        var dataElementFactory = new sparql.ElementFactoryConst(dataConcept.getElement());
        var renamedFilterConceptFactory = new facete.ConceptFactoryRename(filterConceptFactory, varMap);

        var filterElementFactory = new facete.ElementFactoryConceptFactory(renamedFilterConceptFactory);

        //debugger;
        // NOTE We assume the data and filter concept share the same variables
        var elementFactory = new sparql.ElementFactoryCombine(true, [dataElementFactory, filterElementFactory]);
                
            
        var queryFactory = new facete.QueryFactoryTableMod(elementFactory, tableMod);
                       
            
        $scope.active.essentialFacetTableConfig = {
            queryFactory: queryFactory,
            tableMod: tableMod
        };
        

        var allElementFactory = new sparql.ElementFactoryCombine(true, [dataElementFactory, facetElementFactory]);
        var allQueryFactory = new facete.QueryFactoryTableMod(allElementFactory, tableMod);
        $scope.active.allEssentialFacetTableConfig = {
            queryFactory: allQueryFactory,
            tableMod: tableMod
        };
    };


    }]);
	</script>

</head>

<body ng-controller="FaceteAppCtrl">

	<nav class="navbar navbar-default" role="navigation">
		<div class="container-fluid">
			<!-- Brand and toggle get grouped for better mobile display -->
   			<div class="navbar-header">
				<button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
					<span class="sr-only">Toggle navigation</span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
				</button>
				
				<a class="navbar-brand" style="padding: 3px 15px;" href="#"><img style="height: 42px;" src="images/logo-eccenca-plain.png" alt=""></img></a>
				<a class="navbar-brand" href="#">Facete II</a>
			</div>

			<div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
				 <form class="navbar-form navbar-left" role="search">
	        		<div class="form-group">
	          			<input type="text" ng-model="app.searchString" class="form-control" placeholder="Find Place...">
	        		</div>
	        		<button type="submit" ng-click="doSearch(app.searchString)" class="btn btn-default">Submit</button>
				</form>

<!-- 				<ul class="nav navbar-nav"> -->
<!-- 					<li class="dropdown"><a href="#" class="dropdown-toggle" -->
<!-- 						data-toggle="dropdown">Tools <b class="caret"></b></a> -->
<!-- 						<ul class="dropdown-menu"> -->
<!-- 							<li><a href="#">Interlinking</a></li> -->
<!-- 							<li><a href="#">Fusion</a></li> -->
<!-- 						</ul></li> -->
<!-- 				</ul> -->

				<ul class="nav nav-pills navbar-nav navbar-right">
					<li class="dropdown" ng-class="{'active': (notifications.length > 0)}">
						<a href="#" class="dropdown-toggle" data-toggle="dropdown">Notifications <span class="badge">{{notifications.length}}</span> <b class="caret"></b></a>
						<ul class="dropdown-menu">
							<li ng-if="!(notifications.length > 0)">(empty list)</li>
							<li ng-repeat="item in notifications | reverse">
								<div style="border-style:solid; border-color: #eeeeee; border-width: 1px; margin: 5px; padding: 5px; width: 250px;">
									<b ng-if="item.jobStatus.isCounting">Preparing export (counting)...</b>
									<b ng-if="item.jobStatus.isRetrieving">Preparing export (retrieving)...</b>
									<b ng-if="item.jobStatus.isSucceeded">Export succeeded.</b>
									<b ng-if="item.jobStatus.isFailed">Export failed.</b>
									<a ng-if="item.jobStatus.isSucceeded" class="btn btn-primary btn-large" target="_blank" style="width: 50%"href="api/export/retrieve?id={{item.jobStatus.id}}&format=csv">CSV</a>
									<a ng-if="item.jobStatus.isSucceeded" class="btn btn-primary btn-large" target="_blank" style="width: 50%"href="api/export/retrieve?id={{item.jobStatus.id}}&format=xml">XML</a>
									<progressbar class="active" ng-class="{'progress-striped': item.jobStatus.isRunning}" animate="true" value="item.jobStatus.progress.percentage" type="{{(item.jobStatus.isRunning || item.jobStatus.isSucceeded) ? 'success' : 'danger'}}"><b>{{item.jobStatus.progress.percentage}}%</b></progressbar>
									<span>Processed {{item.jobStatus.progress.current || '0'}} / {{item.jobStatus.progress.max || '?'}} items.</span>
<!-- 								<progressbar class="active progress-striped" ng-class="{'': item.jobStatus.isRunning}" animate="true" value="50" max="100" type="success"><b>50%</b></progressbar> -->
							
								</div>
								<!-- <a href="">{{item}}</a>  -->
								<!-- For now we support only export {started, cancelled, failed and finished} -->
							</li>
<!-- 							<li><a href="#">Action</a></li> -->
<!-- 							<li><a href="#">Another action</a></li> -->
<!-- 							<li><a href="#">Something else here</a></li> -->
<!-- 							<li class="divider"></li> -->
<!-- 							<li><a href="#">Separated link</a></li> -->
						</ul>
					</li>
				</ul>

			</div>
							
<!-- 			<div class="collapse navbar-collapse"> -->
<!--       			<ul class="nav navbar-nav"> -->
<!--         			<li class="active"><a href="#">Source Code</a></li> -->
<!--         			<li><a href="#">Link</a></li> -->
<!--         		</ul> -->
<!--         	</div> -->
		</div>
	</nav>

	<div style="position: absolute; top: 50px; left: 0px; width: 500px; bottom: 0px; overflow: auto; padding: 5px; pointer-events:none" pointer-events-scroll-fix>


		<accordion close-others="false">

			<accordion-group style="pointer-events: auto;" ng-if="app.search.show" is-open="app.search.isOpen">
				<accordion-heading>
					<i class="glyphicon" ng-class="{'glyphicon-chevron-down': app.search.isOpen, 'glyphicon-chevron-right': !app.search.isOpen}"></i>
					Search Results
					<a href="" ng-click="app.search.show = false"><span class="glyphicon glyphicon-remove-circle"></span></a>
				</accordion-heading>
				
				<ul>
				<li ng-show="!(searchResults.length > 0)">(this list is empty)</li>
				<li ng-repeat="item in searchResults">
					<a href="" ng-click="selectSearchResult(item)"><b>{{item.primaryName}}</b></a>
					<span>{{item.description}}</span>
				</li>
				</ul>
			</accordion-group>
		
			<accordion-group style="pointer-events: auto;" is-open="app.dataSources.isOpen">
				<accordion-heading>
					<i class="glyphicon" ng-class="{'glyphicon-chevron-down': app.dataSources.isOpen, 'glyphicon-chevron-right': !app.dataSources.isOpen}"></i>
					Data Sources {{active.service ? '[' + active.service.name + ']': ''}}
				</accordion-heading>

				<select ng-model="active.service" ng-options="item.name for item in active.serviceConfigs"></select>

				<br />
				<button class="btn btn-primary" ng-class="{'active': app.dataSources.showAddDialog}" ng-click="app.dataSources.showAddDialog=!app.dataSources.showAddDialog">Add Data Source</button>
				<button ng-if="active.service" class="btn" ng-click="deleteDataSource(active.service.id)">Delete Selected Data Source</button>
				
			</accordion-group>

<!-- 			<accordion-group style="pointer-events: auto;" is-open="isOpenConcepts"> -->
<!-- 				<accordion-heading> -->
<!-- 					<i class="glyphicon" ng-class="{'glyphicon-chevron-down': isOpenConcepts, 'glyphicon-chevron-right': !isOpenConcepts}"></i> -->
<!-- 					Concepts {{active.service ? '[' + active.service.name + ']': ''}} -->
<!-- 				</accordion-heading> -->
				
<!-- 				<ul> -->
<!-- 			    	<li ng-show="conceptSpaces.length == 0" class="inactive">(there are no concepts yet)</li> -->
<!-- 				    <li ng-repeat="conceptSpace in conceptSpaces" ng-class="{'highlite': conceptSpace.active}"> -->
<!-- 				    	<a href="" ng-click="removeConceptSpace($index)"><span class="glyphicon glyphicon-remove-circle"></span></a> -->
<!-- 				    	<a href="" ng-click="selectConceptSpace($index)">{{conceptSpace.name}}</a> -->
<!-- 				   	</li> -->
<!-- 				</ul> -->
				
<!-- 				<button class="btn btn-primary" ng-click="addConceptSpace()">Create a new Concept</button> -->
<!-- 			</accordion-group> -->

			<accordion-group class="portlet" style="pointer-events: auto;" is-open="app.geoLinks.isOpen">
				<accordion-heading>
					<i class="glyphicon" ng-class="{'glyphicon-chevron-down': app.geoLinks.isOpen, 'glyphicon-chevron-right': !app.geoLinks.isOpen}"></i>
					GeoLinks
				</accordion-heading>

				<tabset>
					<tab heading="Candidates">
		   				<ul>
		   					<li ng-repeat="geoPath in active.geoPaths">
		   						<a href="" ng-click="setGeoPath(geoPath.path)">{{geoPath.name}}</a>
		   					</li>
		   				</ul>
				  	</tab>
					<tab heading="Active">
						To be done
					</tab>
				</tabset>
			</accordion-group>

			<accordion-group style="pointer-events: auto;" is-open="app.facets.isOpen">
				<accordion-heading>
					<i class="glyphicon" ng-class="{'glyphicon-chevron-down': app.facets.isOpen, 'glyphicon-chevron-right': !app.facets.isOpen}"></i>
					Facets
				</accordion-heading>

				<div class="panel panel-info"> 
					<div class="panel-heading portlet-heading">
						Facet Tree
					</div>
					<div class="panel-body">
					   <facet-tree sparql-service="active.sparqlService" facet-tree-config="active.facetTreeConfig" select="selectFacet(path)" plugins="facetTreePlugins" plugin-context="facetTreePluginContext"></facet-tree>
					</div>
				</div>
		
				<div class="panel panel-info"> 
					<div class="panel-heading portlet-heading">
						Facet Values
					</div>
					<div class="panel-body">
		   				<facet-value-list sparql-service="active.sparqlService" facet-tree-config="active.facetTreeConfig" path="active.path"></facet-value-list>
					</div>
				</div>
		
				<div class="panel panel-info"> 
					<div class="panel-heading portlet-heading">
						Constraints
					</div>
					<div class="panel-body">
		   				<constraint-list sparql-service="active.sparqlService" facet-tree-config="active.facetTreeConfig"></constraint-list>
					</div>
				</div>
			</accordion-group>
		</accordion>

	</div>


    <!-- Note: This div has overflow auto set, but actually it should never be needed -->
	<div style="position: absolute; margin: 0px; bottom: 20px; left: 530px; top: 50px; right: 5px; pointer-events: none;">

		<accordion style="background-color: white; position: absolute; overflow: auto; bottom: 0px; left: 0px; max-height: 100%; min-height: 50px; min-width: 50px; max-width: 100%; pointer-events: auto;" resizable="resizableConfig" bounds="app.data.bounds" ng-style="!app.data.isOpen && {width: '', height: ''}">
			<accordion-group is-open="app.data.isOpen">
				<accordion-heading>
					<i class="glyphicon" ng-class="{'glyphicon-chevron-down': app.data.isOpen, 'glyphicon-chevron-right': !app.data.isOpen}"></i>
					Data
				</accordion-heading>
			
				<tabset>
					<tab heading="All" active="app.data.tabs[0].isActive">
						<button class="btn btn-primary" ng-click="exportAll()">Export</button>
<!-- 						<sparql-grid sparql-service="active.sparqlService" config="active.allFacetTableConfig" disable-requests="!app.data.tabs[0].isActive"></sparql-grid> -->
                        <sparql-table sparql-service="active.sparqlService" config="active.allFacetTableConfig" disable-requests="!app.data.tabs[0].isActive"></sparql-table>
					</tab>
		
					<tab heading="Selection" active="app.data.tabs[1].isActive">
						<sparql-table sparql-service="active.sparqlService" config="active.facetTableConfig" disable-requests="!app.data.tabs[1].isActive"></sparql-table>
					</tab>

                    <tab heading="Essential (All)" active="app.data.tabs[2].isActive">
                        <sparql-table sparql-service="active.sparqlService" config="active.allEssentialFacetTableConfig" disable-requests="!app.data.tabs[2].isActive"></sparql-table>
                    </tab>

                    <tab heading="Essential (Selection)" active="app.data.tabs[3].isActive">
                        <sparql-table sparql-service="active.sparqlService" config="active.essentialFacetTableConfig" disable-requests="!app.data.tabs[3].isActive"></sparql-table>
                    </tab>

<!-- 					<tab heading="Interlinking"> -->
<!-- 						<form class="well form-horizontal"> -->
<!-- 							<div class="form-group"> -->
<!-- 								<label>Source Concept: <input ng-model="edit.name" type="text" class="form-control"></input></label> -->
<!-- 							</div> -->
<!-- 							<div class="form-group">					 -->
<!-- 								<label>Target Concept: <input ng-model="edit.dataServiceIri" type="text" class="form-control"></input></label> -->
<!-- 							</div> -->
<!-- 							<button class="btn btn-primary" ng-click="hideCreateDataSource=true">Cancel</button> -->
<!-- 							<button class="btn btn-primary" ng-click="addDataSource()">Confirm</button>			 -->
<!-- 		            	</form> -->
<!-- 					</tab> -->
                    <tab heading="Find Relations" active="app.data.tabs[4].isActive">
                        <table>
                        <tr><td>
			                <div class="panel panel-info"> 
			                    <div class="panel-heading portlet-heading">
			                        Facet Tree
			                    </div>
			                    <div class="panel-body">
			                       <facet-tree sparql-service="active.sparqlService" facet-tree-config="active.targetFacetTreeConfig" select="selectTargetFacet(path)"></facet-tree>
			                    </div>
			                </div>
			        
			                <div class="panel panel-info"> 
			                    <div class="panel-heading portlet-heading">
			                        Facet Values
			                    </div>
			                    <div class="panel-body">
			                        <facet-value-list sparql-service="active.sparqlService" facet-tree-config="active.targetFacetTreeConfig" path="active.targetPath"></facet-value-list>
			                    </div>
			                </div>
			        
			                <div class="panel panel-info"> 
			                    <div class="panel-heading portlet-heading">
			                        Constraints
			                    </div>
			                    <div class="panel-body">
			                        <constraint-list sparql-service="active.sparqlService" facet-tree-config="active.targetFacetTreeConfig"></constraint-list>
			                    </div>
			                </div>
			            </td><td>
			                 Candidates
			                 <ul>
                            <li ng-repeat="geoPath in active.targetGeoPaths">
                                <a href="">{{geoPath.name}}</a>
                            </li>
			                 </ul>
                        </td></tr>
			            </table>
                    </tab>

				</tabset>
			</accordion-group>
		</accordion>
	</div>

	<div style="position: absolute; margin: 0px; top: 50px; left: 530px; top: 50px; overflow: auto; pointer-events: none;">
		<tabset style="pointer-events: auto;">		
			<tab ng-if="app.dataSources.showAddDialog" heading="Data Source" style="width: 500px;">

				<div style="border-style:solid; background-color:#ffffff; #eeeeee; border-width: 1px; margin: 5px; padding: 5px;">

					<form class="well form-horizontal">
						<div class="form-group">
							<label>Title: <input ng-model="edit.name" type="text" class="form-control"></input></label>
						</div>
						<div class="form-group">					
							<label>Sparql Service Iri: <input ng-model="edit.dataServiceIri" type="text" class="form-control"></input></label>
						</div>
						<div class="form-group">					
							<label>Named Graphs (Separate entries with white space): <input ng-model="edit.dataGraphIris" type="text" class="form-control"></input></label>
						</div>
						<div class="form-group">										
							<label>Join Summary Service: <input ng-model="edit.jsServiceIri" type="text" class="form-control"></input></label>
						</div>
						<div class="form-group">										
							<label>Join Summary Graphs (Separate entries with white space): <input ng-model="edit.jsGraphIris" type="text" class="form-control"></input></label>
						</div>
		
						<button class="btn btn-primary" ng-click="app.dataSources.showAddDialog=false">Cancel</button>
						<button class="btn btn-primary" ng-click="addDataSource()">Confirm</button>			
		           	</form>
				</div>
			</tab>
		</tabset>	
	</div>


    <div jassa-map-ol="map" style="position: absolute; left: 0px; top: 0px; width: 100%; height: 100%; z-index:-9999" config="active.mapConfig" sources="active.dataSources" select="selectGeom(data)" unselect="unselectGeom(data)"></div>



<!-- 	<a href="https://github.com/GeoKnow/Facete2" target="_blank"><img style="position: absolute; top: 0; right: 0; border: 0;" src="images/forkme_right_green_007200.png" alt="Fork me on GitHub"></a> -->

</body>

</html>

